<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IIMC Card Tool</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        :root {
            --bg: #18191a; --card: #242526; --text: #e4e6eb; --border: #3e4042;
            --primary: #478df5; --secondary: #3a3b3c; --danger: #fb6161;
            --success: #28a745; --earth: #2d81ff; --link: #a3c7ff; --dispatch: #f39c12;
            --section-bg: rgba(0,0,0,0.15);
            --input-bg: #3a3b3c;
        }
        [data-theme="light"] {
            --bg: #f0f2f5; --card: #ffffff; --text: #1c1e21; --border: #dadde1;
            --primary: #1a73e8; --secondary: #e4e6eb; --danger: #fa3e3e;
            --link: #1a73e8; --dispatch: #f39c12;
            --section-bg: #f7f8fa; 
            --input-bg: #ffffff; 
        }

        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 10px; background: var(--bg); color: var(--text); transition: background 0.3s; }
        .container { max-width: 900px; margin: auto; background: var(--card); padding: 20px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        
        .header-row { display: flex; justify-content: space-between; align-items: center; border-bottom: 2px solid var(--border); padding-bottom: 15px; margin-bottom: 20px; }
        h2 { margin: 0; color: var(--primary); font-size: 20px; }
        
        .session-status-card { background: var(--secondary); padding: 8px 12px; border-radius: 8px; border: 1px solid var(--border); font-size: 9.5px; margin-bottom: 20px; }
        .status-line { margin-top: 4px; display: flex; justify-content: space-between; align-items: center; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; display: inline-block; flex-shrink: 0; }
        .status-dot.ready { background: var(--success); }
        .status-dot.loading { background: var(--dispatch); animation: dbPulse 1s infinite; }
        @keyframes dbPulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }

        .section-card { border: 1px solid var(--border); border-radius: 8px; padding: 15px; margin-bottom: 15px; background: var(--section-bg); }
        .section-title { font-weight: bold; color: var(--primary); margin-bottom: 12px; text-transform: uppercase; font-size: 10px; letter-spacing: 0.5px; }
        
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        @media (max-width: 480px) { .grid-2 { grid-template-columns: 1fr; } }

        label { display: block; font-weight: bold; color: var(--text); font-size: 12px; margin-bottom: 6px; }
        input[type="number"], input[type="text"] { width: 100%; padding: 12px; background: var(--input-bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; box-sizing: border-box; font-size: 15px; font-weight: bold; -webkit-appearance: none; }
        input[type="number"]:focus, input[type="text"]:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(71, 141, 245, 0.25); transition: all 0.2s ease; }
        
        .btn-group { margin-top: 25px; }
        button.action { width: 100%; padding: 16px; background-color: var(--success); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        
        .output-block { background: var(--input-bg); border: 1px solid var(--border); border-radius: 6px; padding: 15px; text-align: center; }
        .output-label { font-size: 10px; text-transform: uppercase; color: #90949c; font-weight: bold; margin-bottom: 5px; }
        .output-value { font-size: 26px; font-weight: bold; color: var(--text); }
        .output-value.msa-val { color: var(--danger); }
        .output-value.freq-val { color: var(--success); }

        .audit-text { font-size: 11px; color: #c4c8d0; margin-bottom: 8px; font-family: monospace; line-height: 1.4; }
        .audit-sector-card { border-left: 3px solid var(--primary); padding-left: 10px; }
        .audit-grid.multi { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; }
        .audit-grid.multi .audit-sector-card { margin-bottom: 0 !important; border-bottom: none !important; padding-bottom: 0 !important; }
        .audit-highlight { color: var(--text); font-weight: bold; }
        .action-btn { background: var(--card); border: 1px solid var(--border); color: var(--text); padding: 10px; border-radius: 6px; cursor: pointer; }

        /* Map UI Additions */
        .btn-preview { background-color: var(--earth); margin-top: 10px; }
        .btn-preview:hover { background-color: #1a60d4; }
        
        #mapOverlay { 
            display: none; position: fixed; top: 5%; left: 5%; width: 90%; height: 80%; 
            background: var(--card); z-index: 3000; border: 2px solid var(--primary); 
            border-radius: 12px; overflow: hidden; box-shadow: 0 20px 50px rgba(0,0,0,0.8);
        }
        #mapOverlay.maximized { width: 100vw; height: 100vh; top: 0; left: 0; border: none; border-radius: 0; }
        #map { width: 100%; height: 100%; background: #222; }

        .map-command-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: auto; background: rgba(30, 31, 32, 0.98); border: 1px solid var(--border); border-radius: 12px;
            padding: 10px 20px; display: flex; align-items: center; gap: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6); backdrop-filter: blur(12px); z-index: 9999 !important;
        }
        .cmd-group { display: flex; align-items: center; gap: 8px; position: relative; }
        .cmd-divider { width: 1px; height: 24px; background: var(--border); margin: 0 4px; }
        .layer-switch { display: flex; background: rgba(0,0,0,0.4); border-radius: 6px; padding: 2px; border: 1px solid var(--border); }
        .layer-btn { background: transparent; border: none; color: #888; padding: 8px 12px; font-size: 11px; font-weight: 600; cursor: pointer; border-radius: 4px; transition: 0.2s; white-space: nowrap; height: 32px; display: flex; align-items: center; }
        .layer-btn.active { background: var(--primary); color: white; }
        .close-btn { background: var(--danger); border-color: var(--danger); color: white; }

        /* --- KNEEBOARD TEMPLATE STYLES (Shared by Print & Preview) --- */
        #print-container { display: none; font-family: Arial, sans-serif; color: black; }
        
        .print-landscape-sheet { display: flex; flex-direction: row; width: 11in; height: 8.5in; background: white; box-sizing: border-box; margin: 0 auto; }
        .print-page, .print-notes { display: flex; flex-direction: column; width: 5.5in; height: 8.5in; box-sizing: border-box; padding: 0.25in; overflow: hidden; }
        .print-notes { border-left: 1px dashed #ccc; background: white; }
        
        .print-header { display: flex; justify-content: space-between; align-items: stretch; margin-bottom: 0; gap: 0; }
        .print-logo-box, .print-title-box, .print-meta-box { border: 2px solid black; border-bottom: none; padding: 4px; display: flex; flex-direction: column; justify-content: center; box-sizing: border-box; }
        .print-logo-box { width: 18%; text-align: center; border-right: none; }
        .print-title-box { width: 52%; text-align: center; font-weight: bold; container-type: inline-size; display: flex; flex-direction: column; justify-content: center; }
        .print-title { font-size: calc(1.5cqi + 11px); line-height: 1.2; width: 100%; }
        .print-meta-box { width: 30%; font-weight: bold; container-type: inline-size; display: flex; flex-direction: column; justify-content: center; text-align: center; border-left: none; }
        .print-meta { font-size: calc(2.5cqi + 9px); line-height: 1.2; }
        
        .print-body { border: 3px solid black; display: flex; flex-direction: column; flex: 1; box-sizing: border-box; overflow: hidden; }
        
        .print-diagram-section { position: relative; flex: 1; display: flex; justify-content: center; align-items: center; padding: 10px; box-sizing: border-box; overflow: hidden; }
        .print-freq-box { position: absolute; top: 10px; right: 10px; text-align: center; font-size: 11px; font-weight: bold; z-index: 10; background: white; padding: 4px; border: 1px solid black; line-height: 1.1; }
        
        .print-circle-container { width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: white; box-sizing: border-box; border-radius: 50%; }
        .print-circle-container svg { max-width: 100%; max-height: 100%; }
        .print-center-text { text-align: center; font-size: 24px; font-weight: bold; line-height: 1.2; }
        .print-center-text span { font-size: 20px; }
        
        .active-layout-btn { background: var(--primary) !important; color: white !important; border-color: var(--primary) !important; }
        
        .print-instructions-section { border-top: 3px solid #000; padding: 8px 10px; font-size: 10.5px; line-height: 1.2; box-sizing: border-box; }
        .print-avoid { margin-bottom: 6px; font-size: 9.5px; }
        .print-section-title { font-weight: bold; font-size: 11px; margin-bottom: 2px; }
        .print-recover ul { margin: 0; padding-left: 16px; list-style-type: disc; }
        .print-recover li { margin-bottom: 1px; padding-left: 2px; }
        .print-note { font-weight: normal; margin: 4px 0; font-size: 10.5px; }

        .notes-header { font-weight: bold; font-size: 14px; margin-bottom: 10px; text-align: center; text-transform: uppercase; border-bottom: 2px solid black; padding-bottom: 5px; }
        .notes-textarea { flex: 1; width: 100%; border: none; resize: none; font-family: inherit; font-size: 12px; line-height: 1.5; outline: none; background: transparent; }

        /* --- PREVIEW MODE (Screen Only) --- */
        @media screen {
            body.preview-mode { background: #222 !important; overflow-y: auto; overflow-x: auto; }
            body.preview-mode .container, body.preview-mode #mapOverlay { display: none !important; }
            body.preview-mode #print-container { display: flex; flex-direction: column; align-items: center; padding: 40px 20px; min-height: 100vh; transition: padding-left 0.3s ease; }
            body.is-customizing #print-container { padding-left: 280px; }
            body.preview-mode .print-landscape-sheet { background: white; box-shadow: 0 10px 30px rgba(0,0,0,0.8); border-radius: 4px; }
        }

        /* --- ACTUAL PRINT SPOOLER STYLES --- */
        @media print {
            @page { size: letter landscape; margin: 0; }
            body { background: white !important; margin: 0 !important; padding: 0 !important; width: 11in !important; height: 8.5in !important; overflow: hidden !important; -webkit-print-color-adjust: exact; print-color-adjust: exact; text-rendering: optimizeLegibility; }
            .container, #mapOverlay, .customize-sidebar, .modal-overlay, .app-footer, .header-row { display: none !important; }
            #print-container { display: block !important; width: 11in !important; height: 8.5in !important; margin: 0 !important; padding: 0 !important; }
            .print-landscape-sheet { width: 11in !important; height: 8.5in !important; max-width: 100vw !important; max-height: 100vh !important; margin: 0 !important; padding: 0 !important; box-shadow: none !important; border-radius: 0 !important; page-break-after: avoid; page-break-inside: avoid; }
            .print-notes { border-left: 1px dashed transparent !important; }
        }

        /* --- CUSTOMIZE MODE STYLES --- */
        body.is-customizing .print-page { outline: 2px dashed var(--primary); }
        body.is-customizing .draggable-box { cursor: grab; }
        body.is-customizing .draggable-box:active { cursor: grabbing; }
        body.is-dragging .editable-text { outline: none !important; background: transparent !important; }
        body.is-customizing .editable-text { outline: 1px dashed rgba(71, 141, 245, 0.5); background: rgba(71, 141, 245, 0.05); transition: 0.2s; }
        body.is-customizing .editable-text:hover { outline: 2px solid var(--primary); background: rgba(71, 141, 245, 0.1); }
        
        .customize-sidebar {
            position: fixed; top: 0; left: -300px; width: 260px; height: 100vh;
            background: var(--card); border-right: 1px solid var(--border);
            box-shadow: 4px 0 15px rgba(0,0,0,0.5); z-index: 10000;
            padding: 15px; box-sizing: border-box; transition: left 0.3s ease;
            display: flex; flex-direction: column; gap: 12px; overflow-y: auto;
        }
        body.is-customizing .customize-sidebar { left: 0; }
        .customize-sidebar h3 { margin: 0 0 10px 0; color: var(--primary); font-size: 16px; border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        .sidebar-row { display: flex; justify-content: space-between; align-items: center; font-size: 13px; font-weight: bold; }
        .btn-sidebar { background: var(--secondary); color: var(--text); border: 1px solid var(--border); padding: 8px 12px; border-radius: 6px; cursor: pointer; width: 100%; font-weight: bold; margin-top: 10px; }
        .btn-sidebar:hover { background: var(--border); }
        
        @media print {
            .customize-sidebar { display: none !important; }
            .editable-text { outline: none !important; background: transparent !important; }
            .freq-box .editable-text { background: white !important; }
        }

        /* --- UI Updates: Header, Footer, Modals, Print --- */
        .version-subtitle { font-size: 11px; color: var(--link); margin-top: 4px; margin-bottom: 20px; display: inline-block; font-weight: normal; cursor: pointer; text-decoration: underline; }
        .project-link { font-size: 11px; color: #90949c; margin-left: 15px; text-decoration: underline; cursor: pointer; transition: color 0.2s; }
        .project-link:hover { color: var(--link); }
        .app-footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid var(--border); font-size: 11px; color: #90949c; line-height: 1.6; text-align: left; }
        .disclaimer-bold { font-weight: bold; color: var(--text); }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.75); z-index: 5999; }
        #versionHistory { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--card); border: 2px solid var(--primary); padding: 25px; border-radius: 12px; font-size: 12px; z-index: 6000; box-shadow: 0 10px 30px rgba(0,0,0,0.5); max-width: 500px; width: 90%; max-height: 80vh; overflow-y: auto; color: var(--text); line-height: 1.6; }
        @media print { .no-print { display: none !important; } }
    </style>
</head>
<body data-theme="dark">

<div class="modal-overlay no-print" id="historyOverlay" onclick="toggleVersionHistory()">
    <div id="versionHistory" onclick="event.stopPropagation()">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:1px solid var(--border); padding-bottom:10px; position: sticky; top: -25px; background: var(--card); z-index: 10; margin-top: -25px; padding-top: 25px;">
            <strong style="color:var(--primary); font-size:14px;">Version History</strong>
            <span style="cursor:pointer; font-size:18px; opacity:0.7;" onclick="toggleVersionHistory()">✕</span>
        </div>
        <b>v2.4.4</b> - Fixed kneeboard expiration date to align with 56-day DOF.<br>
        <b>v2.4.4</b> - Fixed timezone issue with kneeboard AIRAC date.<br>
        <b>v2.4.3</b> - Added user input data validation logic.<br>
        <b>v2.4.2</b> - Fixed antimeridian wrapping bug (Aleutian Islands / Dateline Fix).<br>
        <b>v2.4.1</b> - Fixed expiration date on kneeboard card to correctly reflect next AIRAC cycle.<br>
        <b>v2.4</b> - Major update - integrated new terrain engine using NumPY array to ensure correct resolution of highest points.<br>
        <b>v2.3</b> - Revised frequency search logic to account FAA encoding of larger airports.<br>
        <b>v2.2</b> - Overhauled kneeboard print options and menu.<br>
        <b>v2.1</b> - Minor UI updates.<br>
        <b>v2.0.1</b> - Transitioned to web-based deployment on GitHub.<br>
        <b>v1.9.5</b> - Updated terrain model to Copernicus GLO-30. Added usage instructions and pre-flight disclaimers.<br>
        <b>v1.9.4</b> - Added Map Preview functionality.<br>
    </div>
</div>

<div class="container">
    <div class="header-row no-print">
        <div>
            <h2 style="margin: 0; color: var(--primary); line-height: 1; font-size: 22px;">IIMC Card Tool</h2>
            <span class="version-subtitle" onclick="toggleVersionHistory()">v2.4.5</span>
            <a href="https://github.com/cwmauze/iimc-card-tool" target="_blank" class="project-link">GitHub project home</a>
            <a href="mailto:cistern_fob3m@icloud.com" class="project-link">Contact / Feedback</a>
        </div>
        <button class="action-btn" onclick="toggleTheme()" id="themeBtn" style="font-size: 16px; padding: 6px 10px; height: auto;">☀️</button>
    </div>

    <div class="grid-2 no-print" style="margin-bottom: 20px; align-items: stretch;">
        <div style="font-size: 13px; color: #90949c; line-height: 1.5; border-left: 2px solid var(--border); padding-left: 15px; display: flex; flex-direction: column; justify-content: center;">
            <strong style="color: var(--text); margin-bottom: 4px;">Pre-Flight Data Prep:</strong>
            <div>1. <strong>Define Location:</strong> Enter an FAA Identifier or precise Lat/Lon and set the action radius.</div>
            <div>2. <strong>Configure Sectors:</strong> Use a standard 360° ring or toggle custom magnetic sectors.</div>
            <div>3. <strong>Audit & Preview:</strong> Verify controlling obstacles/terrain (Copernicus 30m) and preview on the map.</div>
            <div>4. <strong>Export:</strong> Export to .PDF to arrange and print your kneeboard card.</div>
        </div>

        <div class="session-status-card" style="margin-bottom: 0;">
            <div style="font-weight: bold; color: var(--primary); text-transform: uppercase; font-size: 10px;">Database Status</div>
            <div class="status-line">
                <span>Airport/heliport data (NASR):</span>
                <div style="display:flex; align-items:center; gap:8px;">
                    <span id="apt-status">Checking...</span>
                    <div class="status-dot loading" id="apt-dot"></div>
                </div>
            </div>
            <div class="status-line">
                <span>Obstacle data (DOF):</span>
                <div style="display:flex; align-items:center; gap:8px;">
                    <span id="obs-status">Checking...</span>
                    <div class="status-dot loading" id="obs-dot"></div>
                </div>
            </div>
            <div class="status-line">
                <span>Topographical Terrain (Copernicus 30m):</span>
                <div style="display:flex; align-items:center; gap:8px;">
                    <span id="usgs-status">Checking...</span>
                    <div class="status-dot loading" id="usgs-dot"></div>
                </div>
            </div>
            <div class="status-line">
                <span>Magnetic Model (WMM):</span>
                <div style="display:flex; align-items:center; gap:8px;">
                    <span id="mag-status">Checking...</span>
                    <div class="status-dot loading" id="mag-dot"></div>
                </div>
            </div>
        </div>
    </div>

    <style>
        .container { max-width: 1200px !important; transition: max-width 0.3s ease-in-out; }
        .export-toolbar { display: flex; align-items: stretch; gap: 10px; flex: 1; justify-content: flex-end; align-self: center; }
        .export-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px 12px; border-radius: 6px; border: none; color: white; cursor: pointer; text-align: center; transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.2s; min-width: 110px; font-family: inherit; }
        .export-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.3); opacity: 0.95; }
        .export-btn:active { transform: translateY(0); box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .export-icon { margin-bottom: 4px; }
        .export-title { font-size: 12px; font-weight: bold; margin-bottom: 2px; }
        .export-sub { font-size: 8px; text-transform: uppercase; opacity: 0.9; }
        .btn-map { background-color: #4285F4; }
        .btn-pdf { background-color: #0F9D58; }
        .btn-reset { background-color: #DB4437; min-width: 70px; }
        .efb-toggle { position: relative; display: inline-block; width: 44px; height: 24px; margin: 0; }
        .efb-toggle input { opacity: 0; width: 0; height: 0; }
        .efb-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--border); transition: .2s; border-radius: 24px; }
        .efb-slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: var(--text); transition: .2s; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .efb-toggle input:checked + .efb-slider { background-color: var(--primary); }
        .efb-toggle input:checked + .efb-slider:before { transform: translateX(20px); background-color: #fff; }
    </style>

    <div class="section-card">
        <div class="section-title">1. Location Parameters</div>
        
        <div style="display: flex; gap: 20px; margin-bottom: 12px; flex-wrap: wrap;">
            <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; cursor: pointer; margin: 0;">
                <input type="radio" name="centerMode" value="faa" checked onchange="toggleCenterInput()"> FAA Identifier
            </label>
            <label style="display: flex; align-items: center; gap: 5px; font-weight: normal; cursor: pointer; margin: 0;">
                <input type="radio" name="centerMode" value="coord" onchange="toggleCenterInput()"> Lat/Lon Coordinates
            </label>
        </div>

        <div style="display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap; background: var(--section-bg); border: 1px solid var(--border); border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <div style="flex: 0 0 auto; min-width: 260px;">
                <div id="faaWrap">
                    <label>Centerpoint (FAA ID)</label>
                    <input type="text" id="centerpoint" placeholder="E.G. KRWI" style="text-transform: uppercase;" oninput="handleLocationChange()">
                    <div id="facilityName" style="font-size: 11px; font-weight: bold; margin-top: 8px; color: var(--success); min-height: 14px;"></div>
                </div>
                
                <div id="coordWrap" style="display: none;">
                    <div style="display: flex; gap: 10px;">
                        <div style="width: 150px;">
                            <label>Latitude</label>
                            <input type="text" id="latInput" placeholder="e.g. 35.85" oninput="handleLocationChange()">
                        </div>
                        <div style="width: 150px;">
                            <label>Longitude</label>
                            <input type="text" id="lonInput" placeholder="e.g. -77.89" oninput="handleLocationChange()">
                        </div>
                        <div style="width: 100px;">
                            <label>ID</label>
                            <input type="text" id="customLabel" placeholder="e.g. LZ-1" style="text-transform: uppercase;" oninput="handleLocationChange()" maxlength="6">
                        </div>
                    </div>
                    <div id="coordHelper" style="font-size: 11px; font-weight: bold; margin-top: 8px; color: var(--link); min-height: 14px;">Accepts decimal or DMS</div>
                </div>
            </div>

            <div style="width: 1px; min-height: 60px; background: var(--border); align-self: stretch;"></div>

            <div style="display: flex; gap: 20px; align-items: flex-start; flex: 0 0 auto;">
                <div style="width: 75px; flex-shrink: 0;">
                    <label>Radius</label>
                    <input type="number" id="radius" value="30" oninput="triggerLiveUpdate()" style="text-align: center;">
                </div>

                <div style="display: flex; flex-direction: column;">
                    <label>Custom sectors</label>
                    <div style="display: flex; gap: 12px; height: 44px; align-items: center;">
                        <input type="radio" name="sectorMode" id="sm-single" value="single" checked style="display: none;">
                        <input type="radio" name="sectorMode" id="sm-custom" value="custom" style="display: none;">

                        <label class="efb-toggle" title="Toggle Custom Sectors">
                            <input type="checkbox" id="ui-sector-toggle" onchange="syncSectors(this)">
                            <span class="efb-slider"></span>
                        </label>

                        <div id="sector-btn-wrapper" style="display: none; align-items: center; gap: 6px; margin-left: 8px;">
                            <button class="action-btn" id="btn-rem-sector" onclick="removeSectorHandle()" disabled style="padding: 0; width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; border-color: var(--border); line-height: 1;" title="Remove Sector">&minus;</button>
                            <button class="action-btn" id="btn-add-sector" onclick="addSectorHandle()" disabled style="padding: 0; width: 34px; height: 34px; display: flex; align-items: center; justify-content: center; font-size: 20px; font-weight: bold; background: var(--primary); color: white; border: none; line-height: 1;" title="Add Sector">&plus;</button>
                        </div>
                    </div>
                </div>
            </div>

            <div style="width: 1px; min-height: 60px; background: var(--border); align-self: stretch;"></div>

            <div class="export-toolbar">
                <input type="file" id="template-upload" accept=".json" style="display: none;" onchange="loadTemplate(event)">
                
                <button class="export-btn" style="background-color: #546E7A;" onclick="document.getElementById('template-upload').click()">
                    <svg class="export-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>
                    <span class="export-title">Load Setup</span>
                    <span class="export-sub">JSON TEMPLATE</span>
                </button>

                <button class="export-btn btn-map" onclick="showMapPreview()">
                    <svg class="export-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>
                    <span class="export-title">Preview on map</span>
                    <span class="export-sub">STREET / SAT / VFR</span>
                </button>
                
                <button class="export-btn btn-pdf" onclick="generateKneeboard()">
                    <svg class="export-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>
                    <span class="export-title">Generate kneeboard</span>
                    <span class="export-sub">IIMC CARD</span>
                </button>

                <button class="export-btn btn-reset" onclick="resetApp()">
                    <svg class="export-icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
                    <span class="export-title">CLEAR</span>
                    <span class="export-sub">ALL DATA</span>
                </button>
            </div>
        </div>

        <script>
            function syncSectors(checkbox) {
                document.getElementById('sm-custom').checked = checkbox.checked;
                document.getElementById('sm-single').checked = !checkbox.checked;
                toggleSectorUI();
            }

            function resetApp() {
                document.getElementById('centerpoint').value = '';
                document.getElementById('latInput').value = '';
                document.getElementById('lonInput').value = '';
                document.getElementById('customLabel').value = '';
                document.getElementById('radius').value = '30';
                
                document.querySelector('input[name="centerMode"][value="faa"]').checked = true;
                toggleCenterInput();
                
                const toggleBtn = document.getElementById('ui-sector-toggle');
                if (toggleBtn) {
                    toggleBtn.checked = false;
                    syncSectors(toggleBtn);
                }
                
                document.getElementById('audit-container').innerHTML = '';
                document.getElementById('out-msa').innerText = '--';
                document.getElementById('out-pri-freq').innerText = '--';
                document.getElementById('out-pri-name').innerText = '';
                document.getElementById('out-ctr-freq').innerText = '--';
                document.getElementById('out-ctr-name').innerText = '';
                
                // FIX: Reset the MagVar UI status text
                const magUi = document.getElementById('mag-status');
                if (magUi) {
                    magUi.innerText = "Verified (WMM 2025-2030 Epoch)";
                }
                
                currentCalc = null;
                
                // FIX: Wipe the persistent sector math back to a clean slate
                wheelSectors = [0, 90, 180, 270];
                window.currentSectors = [];
                draggingHandle = null;
                
                // Force the background wheel to redraw with the fresh data
                if (typeof updateWheel === 'function') {
                    updateWheel();
                }
            }
        </script>

        <div id="sectorUI" style="display: none;">
            <div class="wheel-container" style="text-align: center; margin-bottom: 15px;">
                <svg class="wheel-svg" viewBox="-135 -135 270 270" style="width: 100%; max-width: 700px; height: auto; overflow: visible;" id="sector-wheel">
                    <circle cx="0" cy="0" r="100" fill="rgba(255,255,255,0)" stroke="var(--border)" stroke-width="2" />
                    <circle cx="0" cy="0" r="6" class="wheel-center" fill="var(--text)" />
                </svg>
            </div>
        </div>
    </div>

    <div class="section-card" id="audit-section" style="background: rgba(0,0,0,0.25);">
        <div class="section-title">2. Calculation Audit</div>
        <div id="audit-container" class="audit-grid">
            <div class="audit-sector-card" id="audit-single">
                <div class="audit-text" id="audit-terr">Highest terrain: --</div>
                <div class="audit-text" id="audit-obs">Highest obstacle: --</div>
                <div class="audit-text" style="margin-top: 10px; border-top: 1px solid var(--border); padding-top: 10px;" id="audit-math">Formula: --</div>
            </div>
        </div>
    </div>

    <div class="section-card" id="output-section">
        <div class="section-title">3. Emergency Action Plan</div>
        <div style="display: flex; gap: 15px; align-items: stretch; flex-wrap: wrap;">
            <div class="output-block" style="flex: 1.5; margin-bottom: 0; border: 2px solid var(--danger); background: rgba(251, 97, 97, 0.05);">
                <div class="output-label" style="color: var(--danger);">Minimum Safe Altitude (MSA)</div>
                <div class="output-value msa-val" id="out-msa">--</div>
            </div>
            <div class="output-block" style="flex: 1; margin-bottom: 0;">
                <div class="output-label">Nearest Approach</div>
                <div class="output-value freq-val" id="out-pri-freq">--</div>
                <div id="out-pri-name" style="font-size: 10px; color: var(--link); margin-top: 5px; text-transform: uppercase;"></div>
            </div>
            <div class="output-block" style="flex: 1; margin-bottom: 0;">
                <div class="output-label">Overlying Center</div>
                <div class="output-value freq-val" id="out-ctr-freq">--</div>
                <div id="out-ctr-name" style="font-size: 10px; color: var(--link); margin-top: 5px; text-transform: uppercase;"></div>
            </div>
        </div>
    </div>
    
    <footer class="app-footer no-print">
        <span class="disclaimer-bold">DISCLAIMER:</span> This tool is strictly designed to assist pilots in pre-flight planning and the development of local IIMC procedures. The pilot in command remains solely responsible for verifying all altitudes, frequencies, and headings against current, official flight information publications prior to flight.
    </footer>
</div>

<div id="mapOverlay">
    <div class="map-command-bar">
        <div class="cmd-group">
            <div class="layer-switch">
                <button class="layer-btn active" id="b-street" onclick="setBaseView('street')">Map Light</button>
                <button class="layer-btn" id="b-dark" onclick="setBaseView('dark')">Map Dark</button>
                <button class="layer-btn" id="b-sat" onclick="setBaseView('sat')">Satellite</button>
                <button class="layer-btn" id="b-vfr" onclick="setBaseView('vfr')">VFR Sectional</button>
            </div>
        </div>
        <div class="cmd-divider"></div>
        <div class="cmd-group" style="margin-left:auto;">
            <button class="action-btn" onclick="toggleMaximize()">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7"></path></svg>
            </button>
            <button class="action-btn close-btn" onclick="hideMap()">Close</button>
        </div>
    </div>
    <div id="map"></div>
</div> 

<div id="print-container">
    <div class="customize-sidebar" id="customizeSidebar">
        <div style="font-size: 11px; color: #a0a4ac; line-height: 1.4; margin-bottom: 10px;">
            <b>Instructions:</b><br>
            • <b>Drag</b> items to move them.<br>
            • <b>Click</b> highlighted text to edit.<br>
            • Changes appear exactly as printed.
        </div>
        
        <div id="customization-sliders" style="border-bottom: 1px solid var(--border); padding-bottom: 12px; margin-bottom: 12px;">
            <div style="margin-bottom: 12px;">
                <label style="font-size: 11px; margin-bottom: 4px; display: block; color: var(--text);">MSA Text Size <span id="val-msa-scale" style="float: right; color: var(--success); font-family: monospace;">1.00x</span></label>
                <input type="range" id="slider-msa-scale" min="0.5" max="2.0" step="0.05" value="1.0" style="width: 100%; cursor: pointer;">
            </div>
            <div style="margin-bottom: 12px;">
                <label style="font-size: 11px; margin-bottom: 4px; display: block; color: var(--text);">Frequency box size <span id="val-freq-scale" style="float: right; color: var(--success); font-family: monospace;">1.00x</span></label>
                <input type="range" id="slider-freq-scale" min="0.5" max="2.0" step="0.05" value="1.0" style="width: 100%; cursor: pointer;">
            </div>
            <div style="margin-bottom: 12px;">
                <label style="font-size: 11px; margin-bottom: 4px; display: block; color: var(--text);">Degree Marker Size <span id="val-deg-scale" style="float: right; color: var(--success); font-family: monospace;">1.00x</span></label>
                <input type="range" id="slider-deg-scale" min="0.5" max="2.0" step="0.05" value="1.0" style="width: 100%; cursor: pointer;">
            </div>
            <div style="margin-bottom: 0;">
                <label style="font-size: 11px; margin-bottom: 4px; display: block; color: var(--text);">Degree Marker Distance <span id="val-degDist-scale" style="float: right; color: var(--success); font-family: monospace;">270px</span></label>
                <input type="range" id="slider-degDist-scale" min="120" max="420" step="5" value="270" style="width: 100%; cursor: pointer;">
            </div>
        </div>

        <div class="sidebar-row" style="color: var(--text);">
            <span>Company Logo</span>
            <label class="efb-toggle" style="margin: 0;">
                <input type="checkbox" id="toggle-logo-btn" onchange="togglePrintLogo()">
                <span class="efb-slider"></span>
            </label>
        </div>
        
        <div id="logo-select-wrapper" style="display: none; margin-top: 10px;">
            <select id="logo-selector" onchange="updateLogoImage()" style="width: 100%; padding: 8px; background: var(--input-bg); color: var(--text); border: 1px solid var(--border); border-radius: 6px; font-size: 12px; cursor: pointer;">
                <option value="https://www.metrohealth.org/globalassets/metrohealth-images/life-flight/metro-aviation-logo.jpg">Metro Aviation</option>
                <option value="https://www.globalmedicalresponse.com/img/gmr-logo-web.png">Global Medical Response (GMR)</option>
                <option value="https://phoenixchildrens.org/sites/default/files/2025-04/airmethods-logo_0.png">Air Methods</option>
                <option value="https://www.phiairmedical.com/wp-content/uploads/sites/3/2021/07/PHI-Air-Medical_YLW_WHT.png">PHI Air Medical</option>
                <option value="https://placehold.co/400x120/ffffff/0f9d58?text=CUSTOM+OPERATOR&font=montserrat">Custom Operator</option>
            </select>
        </div>

        <div style="margin-top: 12px; border-top: 1px solid var(--border); padding-top: 12px;">
            <strong style="font-size: 11px; color: var(--text); display: block; margin-bottom: 8px;">Right Half Layout:</strong>
            <div style="display: flex; gap: 8px;" id="layout-btn-group">
                <button class="btn-sidebar active-layout-btn" style="margin-top: 0; font-size: 10px; padding: 6px;" onclick="setRightLayout('blank', this)">Blank</button>
                <button class="btn-sidebar" style="margin-top: 0; font-size: 10px; padding: 6px;" onclick="setRightLayout('duplicate', this)">Duplicate</button>
                <button class="btn-sidebar" style="margin-top: 0; font-size: 10px; padding: 6px;" onclick="setRightLayout('notes', this)">Free Text</button>
            </div>
        </div>
        
        <script>
            function setRightLayout(mode, btn) {
                document.querySelectorAll('#layout-btn-group .btn-sidebar').forEach(b => b.classList.remove('active-layout-btn'));
                btn.classList.add('active-layout-btn');
                
                const rightSide = document.getElementById('notes-side');
                if (mode === 'blank') {
                    rightSide.innerHTML = '';
                } else if (mode === 'duplicate') {
                    rightSide.innerHTML = document.getElementById('card-side').innerHTML;
                } else if (mode === 'notes') {
                    rightSide.innerHTML = '<div class="notes-header">Flight Notes</div><textarea class="notes-textarea" placeholder="Enter free text, frequencies, or flight log details here..."></textarea>';
                }
            }
        </script>
        
        <div style="margin-top: auto; display: flex; flex-direction: column; gap: 8px;">
            <button class="btn-sidebar" style="margin-top: 0;" onclick="generateKneeboard()">Reset Layout</button>
            <button class="btn-sidebar" style="margin-top: 0; background: var(--primary); color: white; border: none;" onclick="saveTemplate()">Save Template</button>
            <button class="btn-sidebar" style="margin-top: 0; background: var(--success); color: white; border: none;" onclick="window.print()">Print Card</button>
            <button class="btn-sidebar" style="margin-top: 0; background: var(--danger); color: white; border: none;" onclick="closePreview()">Close</button>
        </div>
    </div>
    
    <div class="print-landscape-sheet">
        <div class="print-page" id="card-side">
            <div class="print-header">
                <div class="print-logo-box" style="padding: 2px;">
                    <img id="print-logo-img" src="https://www.metrohealth.org/globalassets/metrohealth-images/life-flight/metro-aviation-logo.jpg" style="max-width: 100%; max-height: 45px; object-fit: contain; display: block; margin: 0 auto;">
                </div>
                <div class="print-title-box">
                    <div class="print-title">IIMC procedure for 30 NM radius.<br>MSA chart oriented to MAG N</div>
                </div>
                <div class="print-meta-box">
                    <div class="print-meta">Location: <span id="print-loc-1">---</span><br><span style="color: #40a0c6; text-decoration: underline;">Expires: <span id="print-exp-1">---</span></span></div>
                </div>
            </div>
            
            <div class="print-body">
                <div class="print-diagram-section">
                    <div class="print-freq-box">
                        <u>ATC FREQ: <span id="print-freq-1">---</span></u><br>
                        <span id="print-ctr-1" style="font-weight: bold;">---</span>
                    </div>
                    
                    <div class="print-circle-container" id="print-wheel-1">
                        <div class="print-center-text">
                            <div id="print-center-label-1">---</div>
                            <div>MSA: <span id="print-msa-1">---</span></div>
                        </div>
                    </div>
                </div>
                
                <div class="print-instructions-section">
                    <div class="print-avoid"><i><u>AVOID</u> - Be aware of the WX conditions and be prepared for the possibility of IIMC or loss of visual reference. Always maintain situational awareness and pay close attention to weather changes.</i></div>
                    
                    <div class="print-section-title"><i><u>RECOVER</u></i></div>
                    <div class="print-recover">
                        <ul>
                            <li>Attitude (Level the wings on the attitude indicator)</li>
                            <li>Heading (Maintain the aircraft heading, turning only to avoid known obstacles</li>
                            <li>Power (Adjust engine power to applicable climb power)</li>
                            <li>Airspeed (Adjust airspeed to climb airspeed, after the aircraft is stabilized</li>
                        </ul>
                        <div class="print-note"><b>NOTE:</b> Once established on instruments above 60kts, engage A/P upper modes</div>
                        <ul>
                            <li>Climb to the Minimum Safe Altitude</li>
                            <li>De-goggle when safely able (if applicable)</li>
                            <li>Contact appropriate ATC, or on Guard (121.5) and <b>DECLARE AN EMERGENCY.</b></li>
                            <li>Set transponder to squawk "7700"</li>
                            <li>Request vectors to VFR conditions or if no VFR, request IFR clearance to nearest appropriate landing facility with an approach.</li>
                            <li>Brief other personnel on board of situation (if applicable)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="print-notes" id="notes-side"></div>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>

<script>
function toggleVersionHistory() {
    const overlay = document.getElementById('historyOverlay');
    const box = document.getElementById('versionHistory');
    const isShowing = overlay.style.display === 'block'; 
    overlay.style.display = isShowing ? 'none' : 'block'; 
    box.style.display = isShowing ? 'none' : 'block';
}

let globalAirports = null;
let globalObstacles = null;
let globalMeta = null;
let globalTerrain = null;
let updateTimeout = null;
let currentCalc = null; // Stores calculation state for the map preview

document.addEventListener('DOMContentLoaded', async () => {
    // Fetch Metadata for cycle dates
    try {
        const metaRes = await fetch('metadata.json?nocache=' + new Date().getTime());
        globalMeta = await metaRes.json();
    } catch (e) { console.warn("metadata.json not found."); }

    // Load Databases
    fetch('airports.json?nocache=' + new Date().getTime()).then(r => r.json()).then(data => {
        globalAirports = data;
        let datePart = (globalMeta && globalMeta.apt_date) ? globalMeta.apt_date : "Unknown";
        
        // Dynamically calculate the 4-digit AIRAC cycle (e.g., 2602)
        let cycleLabel = "";
        if (datePart !== "Unknown") {
            const parts = datePart.split('/');
            if (parts.length === 3) {
                // Parse the MM/DD/YY string into a strict UTC Date
                const dbDate = new Date(Date.UTC(2000 + parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1])));
                const baseAirac = new Date(Date.UTC(2026, 0, 22)); // Known Cycle 2601
                
                const diffDays = Math.floor((dbDate - baseAirac) / (1000 * 60 * 60 * 24));
                
                // Divide by 28 days, modulo 13 to reset every year, + 1 for 1-based indexing
                let cycleNum = (Math.floor(diffDays / 28) % 13) + 1;
                if (cycleNum <= 0) cycleNum += 13; // Failsafe for edge cases
                
                const yy = parts[2];
                const nn = cycleNum.toString().padStart(2, '0');
                cycleLabel = `AIRAC ${yy}${nn} | `;
            }
        }
        
        document.getElementById('apt-status').innerText = "Verified (" + cycleLabel + "Eff. " + datePart + " | " + Object.keys(data).length + " airports/heliports found)";
        document.getElementById('apt-dot').className = 'status-dot ready';
    });
    fetch('obstacles.json?nocache=' + new Date().getTime()).then(r => r.json()).then(data => {
        globalObstacles = data;
        let datePart = (globalMeta && globalMeta.dof_date) ? globalMeta.dof_date : "Unknown";
        document.getElementById('obs-status').innerText = "Verified (Eff. " + datePart + " | " + data.length + " obstacles)";
        document.getElementById('obs-dot').className = 'status-dot ready';
    });
  // Load USGS Terrain Grid
    fetch('terrain.json')
        .then(r => { if (!r.ok) throw new Error("HTTP " + r.status); return r.json(); })
        .then(data => {
            globalTerrain = data;
            document.getElementById('usgs-status').innerText = "Verified (Offline Copernicus 30m grid)";
            document.getElementById('usgs-status').style.color = "var(--text)";
            document.getElementById('usgs-dot').className = 'status-dot ready';
            triggerLiveUpdate(); 
        })
        .catch(e => {
            document.getElementById('usgs-status').innerText = "Error: terrain.json missing";
            document.getElementById('usgs-status').style.color = "var(--danger)";
            console.error("Terrain grid fetch failed:", e);
        });

    // Initialize offline World Magnetic Model
    import('https://esm.sh/magvar')
        .then(module => {
            window.wmmModule = module; // Cache globally for instant access
            document.getElementById('mag-status').innerText = "Verified (WMM 2025-2030 Epoch)";
            document.getElementById('mag-status').style.color = "var(--text)";
            document.getElementById('mag-dot').className = 'status-dot ready';
        })
        .catch(e => {
            document.getElementById('mag-status').innerText = "Error: WMM import failed";
            document.getElementById('mag-status').style.color = "var(--danger)";
            console.error("MagVar module fetch failed:", e);
        });
}); // <--- Add this closing parenthesis and semicolon here

function toggleCenterInput() {
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    document.getElementById('faaWrap').style.display = (mode === 'faa') ? 'block' : 'none';
    document.getElementById('coordWrap').style.display = (mode === 'coord') ? 'block' : 'none';
    triggerLiveUpdate();
}

function triggerLiveUpdate() {
    updateFacilityName();
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => {
        updateWheel(); // Forces the center badge to grab the newest text
        calculateIIMC(); // Runs the math and draws the new halos
    }, 700);
}

function handleLocationChange() {
    // If Custom Sectors are ON, forcefully turn them OFF and wipe the slate clean for safety
    const toggleBtn = document.getElementById('ui-sector-toggle');
    if (toggleBtn && toggleBtn.checked) {
        toggleBtn.checked = false;
        syncSectors(toggleBtn);
        wheelSectors = [0, 90, 180, 270];
        window.currentSectors = [];
        draggingHandle = null;
    }
    
    // Proceed with the normal live update
    triggerLiveUpdate();
}

// RESTORED AND UPGRADED FUNCTION
function toggleSectorUI() {
    // Read from the hidden baseline radios synced to the EFB toggle switch
    const customToggle = document.getElementById('sm-custom');
    if (!customToggle) return; // Safety check
    
    const mode = customToggle.checked ? 'custom' : 'single';
    document.getElementById('sectorUI').style.display = mode === 'custom' ? 'block' : 'none';
    
    // Dynamically unhide the compact Add/Remove button wrapper
    const btnWrapper = document.getElementById('sector-btn-wrapper');
    if (btnWrapper) btnWrapper.style.display = mode === 'custom' ? 'flex' : 'none';

    if (mode === 'custom' && wheelSectors.length === 0) wheelSectors = [0, 90, 180, 270];
    updateWheel();
    
    // Rely on the proven 700ms sequence to ensure the SVG canvas is fully painted before drawing text
    triggerLiveUpdate();
}

function parseCoordinate(str) {
    str = str.trim().toUpperCase();
    if(!str) return NaN;
    
    // Explicitly check for South, West, or a leading negative sign
    let mult = (str.includes('S') || str.includes('W') || str.startsWith('-')) ? -1 : 1;
    
    // Strip N, S, E, W, and the minus sign so we are left with pure numbers and decimals
    str = str.replace(/[NSWE\-]/g, '').trim();
    
    // Split on anything that is NOT a digit or a decimal point (like spaces or degree symbols)
    let parts = str.split(/[^\d\.]+/).filter(p => p);
    
    if(parts.length === 1) return parseFloat(parts[0]) * mult;
    if(parts.length === 2) return (parseFloat(parts[0]) + parseFloat(parts[1])/60) * mult;
    if(parts.length >= 3) return (parseFloat(parts[0]) + parseFloat(parts[1])/60 + parseFloat(parts[2])/3600) * mult;
    
    return NaN;
}

function updateFacilityName() {
    if(!globalAirports) return;
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    
    if (mode === 'faa') {
        let id = document.getElementById('centerpoint').value.toUpperCase().trim();
        let center = globalAirports[id] || ((id.length === 4 && id.startsWith('K')) ? globalAirports[id.substring(1)] : undefined);
        const nameDiv = document.getElementById('facilityName');
        if (center) {
            nameDiv.innerText = "Facility: " + center.name;
            nameDiv.style.color = "var(--success)";
        } else {
            nameDiv.innerText = id.length > 0 ? "ID NOT FOUND" : "";
            nameDiv.style.color = "var(--danger)";
        }
    } else {
        let clat = parseCoordinate(document.getElementById('latInput').value);
        let clon = parseCoordinate(document.getElementById('lonInput').value);
        const helperDiv = document.getElementById('coordHelper');
        
        if (isNaN(clat) || isNaN(clon)) {
            helperDiv.innerText = "Accepts decimal or DMS";
            helperDiv.style.color = "var(--link)";
        } else if (clat < -90 || clat > 90 || clon < -180 || clon > 180) {
            helperDiv.innerText = "OUT OF BOUNDS: Lat [-90, 90], Lon [-180, 180]";
            helperDiv.style.color = "var(--danger)";
        } else {
            helperDiv.innerText = `Valid coords: ${clat.toFixed(4)}, ${clon.toFixed(4)}`;
            helperDiv.style.color = "var(--success)";
        }
    }
}

function haversineNM(lat1, lon1, lat2, lon2) {
    const R = 3440.065; 
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.pow(Math.sin(dLat/2), 2) + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.pow(Math.sin(dLon/2), 2);
    return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

// NEW: Math helpers for Sector calculations
function calculateBearing(lat1, lon1, lat2, lon2) {
    const l1 = lat1 * Math.PI / 180;
    const l2 = lat2 * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const y = Math.sin(dLon) * Math.cos(l2);
    const x = Math.cos(l1) * Math.sin(l2) - Math.sin(l1) * Math.cos(l2) * Math.cos(dLon);
    return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
}

function isBearingInSector(bearing, startDeg, endDeg) {
    if (startDeg === 0 && endDeg === 360) return true; // Single Radius mode
    if (startDeg < endDeg) return bearing >= startDeg && bearing < endDeg;
    return bearing >= startDeg || bearing < endDeg; // Handles slices crossing North (360/0)
}

// NEW: Multi-Sector capable terrain scanner
async function getPeakTerrain(lat, lon, radiusNM, sectors) {
    // Default to a single 360-degree sector if none are provided
    if (!sectors) sectors = [{ id: 'single', start: 0, end: 360 }];
    if (!globalTerrain) return sectors.map(s => ({ msl: 0, lat, lon, sectorId: s.id }));

    // Calculate grid search boundaries accounting for spherical Earth convergence
    const latOffset = radiusNM / 60.0;
    const lonOffset = (radiusNM / 60.0) / Math.abs(Math.cos(lat * (Math.PI / 180)));
    
    const minLat = lat - latOffset;
    const maxLat = lat + latOffset;
    const minLon = lon - lonOffset;
    const maxLon = lon + lonOffset;
    
    // Initialize an array of peak records, one for each requested sector
    let peaks = sectors.map(s => ({ msl: 0, lat: lat, lon: lon, sectorId: s.id, start: s.start, end: s.end }));

    // Convert bounds to integers (x10) to prevent floating point drift and skipped edges
    const startLatInt = Math.floor(minLat * 10);
    const endLatInt = Math.ceil(maxLat * 10);
    const startLonInt = Math.floor(minLon * 10);
    const endLonInt = Math.ceil(maxLon * 10);

    // Iterate through the grid sectors that fall within the bounding box
    for (let latInt = startLatInt; latInt <= endLatInt; latInt++) {
        for (let lonInt = startLonInt; lonInt <= endLonInt; lonInt++) {
            
            const currentLat = latInt / 10;
            let currentLon = lonInt / 10;
            
            // NEW: Antimeridian Wrapping (Aleutian Islands / Dateline Fix)
            if (currentLon > 180) currentLon -= 360;
            if (currentLon < -180) currentLon += 360;
            
            // Format the key to match our terrain.json dictionary (e.g., "39.2_-106.3")
            const key = `${currentLat.toFixed(1)}_${currentLon.toFixed(1)}`;
            const sectorElev = globalTerrain[key];

            if (sectorElev) {
                // Handle both old integer format and new exact-coordinate array format
                const isArray = Array.isArray(sectorElev);
                const elev = isArray ? sectorElev[0] : sectorElev;
                const peakLat = isArray ? sectorElev[1] : currentLat;
                const peakLon = isArray ? sectorElev[2] : currentLon;

                // Double check if this specific peak is actually within the circular radius
                const dist = haversineNM(lat, lon, peakLat, peakLon);
                const buffer = isArray ? 0 : 4; // Keep 4NM buffer only for old generic grid points

                if (dist <= radiusNM + buffer) { 
                    const brg = calculateBearing(lat, lon, peakLat, peakLon);
                    
                    // Compete for the highest elevation in whichever sector(s) this grid point falls into
                    sectors.forEach((s, idx) => {
                        if (isBearingInSector(brg, s.start, s.end)) {
                            if (elev > peaks[idx].msl) {
                                peaks[idx].msl = elev;
                                peaks[idx].lat = peakLat;
                                peaks[idx].lon = peakLon;
                            }
                        }
                    });
                }
            }
        }
    }

    return peaks;
}

// NEW: Calculate Magnetic Declination using offline Client-Side WMM (2025-2030 Epoch)
async function getMagVar(lat, lon) {
    try {
        // Use the globally cached module to ensure instant offline math
        const module = window.wmmModule || await import('https://esm.sh/magvar');
        const dec = module.magvar(lat, lon);
        return parseFloat(dec);
    } catch (e) {
        console.warn("Offline WMM calculation failed, defaulting to 0° (True North).", e);
        return 0;
    }
}

async function calculateIIMC() {
    if(!globalAirports || !globalObstacles) return;
    
    const mode = document.querySelector('input[name="centerMode"]:checked').value;
    const sectorMode = document.querySelector('input[name="sectorMode"]');
    const isCustomSectors = sectorMode ? document.querySelector('input[name="sectorMode"]:checked').value === 'custom' : false;
    // RED CELL FIX 1: Radius RAM Exhaustion Check
    let radius = parseFloat(document.getElementById('radius').value);
    if(isNaN(radius) || radius < 1) radius = 1;
    if(radius > 150) radius = 150; // Hard cap to prevent browser memory crashes
    
    // Update the UI if we auto-clamped the value
    if (document.getElementById('radius').value != radius) document.getElementById('radius').value = radius;

    let centerTarget = null;
    let isInvalid = false;

    if (mode === 'faa') {
        let id = document.getElementById('centerpoint').value.toUpperCase().trim();
        if (id.length > 0) {
            centerTarget = globalAirports[id] || ((id.length === 4 && id.startsWith('K')) ? globalAirports[id.substring(1)] : undefined);
            if(!centerTarget) isInvalid = true;
        } else {
            return; // Empty input, wait for user to type
        }
    } else {
        let clat = parseCoordinate(document.getElementById('latInput').value);
        let clon = parseCoordinate(document.getElementById('lonInput').value);
        if (isNaN(clat) || isNaN(clon) || clat < -90 || clat > 90 || clon < -180 || clon > 180) {
            isInvalid = true;
        } else {
            centerTarget = { lat: clat, lon: clon, primary_freq: "None", center_freq: "None", name: "Custom Coordinates", center_id: "" };
        }
    }

    // RED CELL FIX 2: The "Ghost Card" Prevention
    if (isInvalid) {
        document.getElementById('out-msa').innerText = "--";
        document.getElementById('out-pri-freq').innerText = "--";
        document.getElementById('out-pri-name').innerText = "INVALID LOCATION";
        document.getElementById('out-ctr-freq').innerText = "--";
        document.getElementById('out-ctr-name').innerText = "";
        document.getElementById('audit-container').innerHTML = '<div class="audit-sector-card"><div class="audit-text" style="color: var(--danger); font-weight: bold;">ERROR: Invalid Location Parameters. Fix inputs to calculate MSA.</div></div>';
        currentCalc = null; // Lock out the Map Preview & PDF Print to prevent stale data usage
        return;
    }

    document.getElementById('out-msa').innerText = "SEARCHING...";

    // NEW: Fetch Magnetic Variation and update the Hybrid UI Status
    const magVar = await getMagVar(centerTarget.lat, centerTarget.lon);
    centerTarget.magVar = magVar; // Save to target for the Map Preview offset
    
    const magUi = document.getElementById('mag-status');
    if (magUi) {
        let dir = magVar >= 0 ? "E" : "W";
        magUi.innerHTML = `Verified (WMM 2025-2030 | <span style="color: var(--success); font-weight: bold;">${Math.abs(magVar).toFixed(1)}° ${dir} applied</span>)`;
    }

    // Define Active Sectors (Relies on window.currentSectors from Phase C SVG engine)
    let activeSectors = (isCustomSectors && window.currentSectors) ? window.currentSectors : [{ id: 'single', start: 0, end: 360, label: '360°' }];
    
    // NEW: Convert Magnetic Sectors to True North for the search engine mapping
    let trueSectors = activeSectors.map(s => ({
        id: s.id,
        start: (s.start === 0 && s.end === 360) ? 0 : (s.start + magVar + 360) % 360,
        end: (s.start === 0 && s.end === 360) ? 360 : (s.end + magVar + 360) % 360,
        label: s.label
    }));

    // Initialize results array matching activeSectors, holding both sets of boundaries
    let results = activeSectors.map((s, idx) => ({
        sector: s,
        trueSector: trueSectors[idx],
        maxObs: { msl: 0, lat: 0, lon: 0 },
        bestPri: null, dPri: 1000000,
        bestCtr: null, dCtr: 1000000
    }));

    const artccMap = {"ZAB":"Albuquerque","ZAN":"Anchorage","ZAU":"Chicago","ZBW":"Boston","ZDC":"Washington","ZDV":"Denver","ZFW":"Fort Worth","ZHU":"Houston","ZID":"Indianapolis","ZJX":"Jacksonville","ZKC":"Kansas City","ZLA":"Los Angeles","ZLC":"Salt Lake","ZMA":"Miami","ZME":"Memphis","ZMP":"Minneapolis","ZNY":"New York","ZOA":"Oakland","ZOB":"Cleveland","ZSE":"Seattle","ZTL":"Atlanta","ZSU":"San Juan","ZUA":"Guam","ZHN":"Honolulu"};

    // Base comms if centerTarget has them
    let basePri = centerTarget.primary_freq !== "None" ? centerTarget : null;
    let baseCtr = centerTarget.center_freq !== "None" ? centerTarget : null;

    // Sector-specific Frequency Search (Using True North Sectors)
    for (let k in globalAirports) {
        let a = globalAirports[k];
        let d = haversineNM(centerTarget.lat, centerTarget.lon, a.lat, a.lon);
        if (d > radius * 3) continue; 
        
        let brg = calculateBearing(centerTarget.lat, centerTarget.lon, a.lat, a.lon);
        results.forEach(r => {
            if (isBearingInSector(brg, r.trueSector.start, r.trueSector.end)) {
                if (a.primary_freq !== "None" && d < r.dPri) { r.dPri = d; r.bestPri = a; }
                if (a.center_freq !== "None" && d < r.dCtr) { r.dCtr = d; r.bestCtr = a; }
            }
        });
    }
    
    // Fallback to centerTarget if no sector-specific comms found
    results.forEach(r => {
        if (!r.bestPri && basePri) r.bestPri = basePri;
        if (!r.bestCtr && baseCtr) r.bestCtr = baseCtr;
    });

    // Sector-specific Obstacle Search (Using True North Sectors)
    globalObstacles.forEach(o => {
        let d = haversineNM(centerTarget.lat, centerTarget.lon, o.lat, o.lon);
        if (d <= radius) {
            let brg = calculateBearing(centerTarget.lat, centerTarget.lon, o.lat, o.lon);
            results.forEach(r => {
                if (isBearingInSector(brg, r.trueSector.start, r.trueSector.end) && o.msl > r.maxObs.msl) {
                    r.maxObs = { msl: o.msl, lat: o.lat, lon: o.lon };
                }
            });
        }
    });

    // Sector-specific Terrain Search (Pass True North Sectors to the terrain scanner)
    const terrPeaks = await getPeakTerrain(centerTarget.lat, centerTarget.lon, radius, trueSectors);

    // Process final calculations and UI
    const auditContainer = document.getElementById('audit-container');
    auditContainer.innerHTML = '';
    auditContainer.className = activeSectors.length > 1 ? 'audit-grid multi' : 'audit-grid';
    
    let highestOverallMSA = 0;
    let highestOverallPri = null;
    let highestOverallCtr = null;

    results.forEach((r, idx) => {
        const terr = terrPeaks[idx];
        const rawPeak = Math.max(r.maxObs.msl, terr.msl);
        
        // Add 100' TERPS pad to the raw peak
        const peak = rawPeak + 100; 
        
        const finalMSA = Math.ceil((peak + 1000) / 100) * 100;
        const isObs = r.maxObs.msl > terr.msl;
        r.terr = terr;
        r.finalMSA = finalMSA;
        r.isObs = isObs;

        if (finalMSA > highestOverallMSA) {
            highestOverallMSA = finalMSA;
            highestOverallPri = r.bestPri;
            highestOverallCtr = r.bestCtr;
        }

        // Build Audit Card(s)
        // Added a bottom border to separate sectors, and removed the confusing top border from the controlling factor line
        let cardHTML = `<div class="audit-sector-card" style="padding-bottom: 12px; margin-bottom: 12px; border-bottom: ${idx < activeSectors.length - 1 ? '1px solid var(--border)' : 'none'};">`;
        if (activeSectors.length > 1) cardHTML += `<div class="audit-sector-title">Sector ${idx+1} (${r.sector.label}) - MSA ${finalMSA}'</div>`;
        cardHTML += `<div class="audit-text">Highest Terrain: <span class="audit-highlight">${Math.round(terr.msl)}' MSL</span> (Lat ${terr.lat.toFixed(4)}, Lon ${terr.lon.toFixed(4)})</div>`;
        cardHTML += `<div class="audit-text">${r.maxObs.msl > 0 ? `Highest Obstacle: <span class="audit-highlight">${r.maxObs.msl}' MSL</span> (Lat ${r.maxObs.lat.toFixed(4)}, Lon ${r.maxObs.lon.toFixed(4)})` : `Highest Obstacle: <span class="audit-highlight">None Found</span>`}</div>`;
        cardHTML += `<div class="audit-text" style="margin-top: 10px;">Controlling factor: <span class="audit-highlight">${isObs ? "Obstacle" : "Terrain"} (${Math.round(rawPeak)}')</span> + 100' TERPS pad + 1000' buffer &rarr; <span class="audit-highlight">MSA ${finalMSA}'</span></div>`;
        cardHTML += `</div>`;
        auditContainer.innerHTML += cardHTML;
    });

    // Update Section 3 main output block depending on mode
    if (activeSectors.length === 1) {
        document.getElementById('out-msa').innerText = highestOverallMSA + " MSL";
        document.getElementById('out-pri-freq').innerText = highestOverallPri ? (highestOverallPri.primary_freq || "N/A") : "N/A";
        document.getElementById('out-pri-name').innerText = highestOverallPri ? highestOverallPri.name + " Approach" : "";
        document.getElementById('out-ctr-freq').innerText = highestOverallCtr ? (highestOverallCtr.center_freq || "N/A") : "N/A";
        document.getElementById('out-ctr-name').innerText = highestOverallCtr ? (artccMap[highestOverallCtr.center_id] || highestOverallCtr.center_id) + " Center" : "";
    } else {
        // NEW: Override Section 3 for Custom Sectors to emphasize GUARD
        document.getElementById('out-msa').innerHTML = "<span style='font-size: 16px; color: var(--text);'>SEE DIAGRAM</span><br>" + highestOverallMSA + " MAX";
        document.getElementById('out-pri-freq').innerText = "121.5 / 243.0";
        document.getElementById('out-pri-name').innerText = "TUNE GUARD (EMERGENCY)";
        document.getElementById('out-ctr-freq').innerText = "Varies";
        document.getElementById('out-ctr-name').innerText = "See diagram for local ATC";
    }

    // Save state for Map Preview & Kneeboard Template
    currentCalc = {
        center: { lat: centerTarget.lat, lon: centerTarget.lon, name: centerTarget.name || "Custom Coords" },
        radius: radius,
        sectors: results 
    };

    // NEW: Draw Post-Calculation Halo Labels on the SVG
    const svg = document.getElementById('sector-wheel');
    if (svg) {
        // Clear old labels to prevent stacking
        svg.querySelectorAll('.halo-label').forEach(el => el.remove());
        
        if (activeSectors.length > 1) {
            results.forEach(r => {
                let midAngle = r.sector.start + ((r.sector.end < r.sector.start ? r.sector.end + 360 : r.sector.end) - r.sector.start) / 2;
                
                // 1. INNER MSA LABEL
                let msaRad = 68; 
                let mX = msaRad * Math.sin(midAngle * Math.PI / 180);
                let mY = -msaRad * Math.cos(midAngle * Math.PI / 180);

                const msaText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                msaText.setAttribute('x', mX);
                msaText.setAttribute('y', mY);
                msaText.setAttribute('class', 'halo-label dynamic-wheel-elem'); 
                msaText.setAttribute('text-anchor', 'middle');
                msaText.setAttribute('dominant-baseline', 'middle');
                msaText.style.fill = 'var(--danger, #fb6161)';
                msaText.style.fontWeight = 'bold';
                msaText.style.fontSize = '10px';
                msaText.style.pointerEvents = 'none';
                msaText.textContent = `MSA ${r.finalMSA}'`;
                svg.appendChild(msaText);

                // 2. OUTER FACILITY HALO (BOXED & STACKED)
                let haloRad = 105; // Anchored just outside the 100px rim
                let tX = haloRad * Math.sin(midAngle * Math.PI / 180);
                let tY = -haloRad * Math.cos(midAngle * Math.PI / 180);
                
                let appName = r.bestPri ? r.bestPri.name.toUpperCase() : "NONE";
                let appFreq = r.bestPri && r.bestPri.primary_freq !== "None" ? r.bestPri.primary_freq : "N/A";
                let ctrName = r.bestCtr ? (artccMap[r.bestCtr.center_id] || r.bestCtr.center_id).toUpperCase() + " CTR" : "NONE CTR";
                let ctrFreq = r.bestCtr && r.bestCtr.center_freq !== "None" ? r.bestCtr.center_freq : "N/A";

                let lines = [
                    { text: appName, fill: 'var(--text, #fff)', weight: 'bold' },
                    { text: `APP: ${appFreq}`, fill: 'var(--text, #fff)', weight: 'normal' },
                    { text: ctrName, fill: 'var(--text, #ccc)', weight: 'bold' },
                    { text: ctrFreq, fill: 'var(--text, #ccc)', weight: 'normal' }
                ];

                // Dynamically size the box width based on the longest string
                let maxChars = Math.max(...lines.map(l => l.text.length));
                let boxW = Math.max(75, maxChars * 4.2); // Prevents short names from getting squished
                let boxH = 34;

                // Smart anchor offset: pushes the box outward dynamically based on quadrant
                // so it neatly flanks the wheel instead of overlapping it
                let offsetX = (midAngle > 45 && midAngle < 135) ? boxW/2 : ((midAngle > 225 && midAngle < 315) ? -boxW/2 : 0);
                let offsetY = (midAngle <= 45 || midAngle >= 315) ? -boxH/2 : ((midAngle >= 135 && midAngle <= 225) ? boxH/2 : 0);

                let cX = tX + offsetX;
                let cY = tY + offsetY;

                // Draw the Box Background
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', cX - boxW/2);
                rect.setAttribute('y', cY - boxH/2);
                rect.setAttribute('width', boxW);
                rect.setAttribute('height', boxH);
                rect.setAttribute('rx', '4'); // Rounded corners
                rect.setAttribute('class', 'halo-label dynamic-wheel-elem');
                rect.style.fill = 'var(--card, #242526)';
                rect.style.stroke = 'var(--border, #3e4042)';
                rect.style.strokeWidth = '1';

                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('class', 'halo-label dynamic-wheel-elem');
                
                const textNode = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                textNode.setAttribute('text-anchor', 'middle');
                textNode.style.fontFamily = 'sans-serif';
                textNode.style.fontSize = '6px'; 
                textNode.style.pointerEvents = 'none'; 

                let lineH = 7.5; 
                let startY = cY - (3 * lineH / 2) + 0.5; // Perfectly center text in the new box

                lines.forEach((lineObj, i) => {
                    const ts = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    ts.setAttribute('x', cX);
                    if (i === 0) {
                        ts.setAttribute('y', startY);
                    } else {
                        ts.setAttribute('dy', lineH);
                    }
                    ts.style.fill = lineObj.fill;
                    ts.style.fontWeight = lineObj.weight;
                    ts.textContent = lineObj.text;
                    textNode.appendChild(ts);
                });

                svg.appendChild(rect);
                g.appendChild(textNode);
                svg.appendChild(g);
            });
        }
    }
}

function toggleTheme() {
    const isL = document.body.getAttribute('data-theme') === 'light';
    document.body.setAttribute('data-theme', isL ? 'dark' : 'light');
    document.getElementById('themeBtn').innerText = isL ? '☀️' : '🌙';
}

// NEW: SVG Sector Wheel Logic
let wheelSectors = [0, 90, 180, 270]; // Default starting angles
let draggingHandle = null;
window.currentSectors = [];

function getAngleFromPointer(e, svg) {
    const pt = svg.createSVGPoint();
    pt.x = e.clientX; pt.y = e.clientY;
    const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
    let angle = Math.atan2(svgP.x, -svgP.y) * 180 / Math.PI;
    return (angle < 0) ? angle + 360 : angle;
}

function updateWheel() {
    const svg = document.getElementById('sector-wheel');
    if (!svg) return;

    // --- DRAG FIX: Move tracking to the parent SVG so capture never drops ---
    svg.onpointermove = (e) => {
        if (draggingHandle !== null) {
            e.preventDefault();
            let newAngle = getAngleFromPointer(e, svg);
            wheelSectors[draggingHandle] = newAngle;
            wheelSectors.sort((a,b) => a - b);
            draggingHandle = wheelSectors.indexOf(newAngle);
            updateWheel();
        }
    };
    svg.onpointerup = (e) => {
        if (draggingHandle !== null) {
            draggingHandle = null;
            triggerLiveUpdate();
        }
    };
    svg.onpointerleave = (e) => {
        if (draggingHandle !== null) {
            draggingHandle = null;
            triggerLiveUpdate();
        }
    };
    // -----------------------------------------------------------------------

    // Clear dynamic elements
    svg.querySelectorAll('.dynamic-wheel-elem').forEach(el => el.remove());
    
    // Force base circle transparency (fixes iOS bug)
    const baseCircle = svg.querySelector('circle');
    if(baseCircle) baseCircle.setAttribute('fill', 'rgba(255,255,255,0)');
    
    wheelSectors.sort((a,b) => a - b);
    window.currentSectors = [];
    
    for (let i = 0; i < wheelSectors.length; i++) {
        let start = wheelSectors[i];
        let end = wheelSectors[(i + 1) % wheelSectors.length];
        let labelText = `${Math.round(start)}° - ${Math.round(end)}°`;
        if (wheelSectors.length === 1) { end = start + 360; labelText = '360°'; }
        
        window.currentSectors.push({
            id: 'sector_' + i,
            start: start,
            end: end === start ? 360 : end,
            label: labelText
        });

        // Draw Slices
        if (wheelSectors.length > 1) {
            const startX = 100 * Math.sin(start * Math.PI / 180);
            const startY = -100 * Math.cos(start * Math.PI / 180);
            const endX = 100 * Math.sin(end * Math.PI / 180);
            const endY = -100 * Math.cos(end * Math.PI / 180);
            let largeArc = (end < start ? end + 360 : end) - start > 180 ? 1 : 0;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M 0 0 L ${startX} ${startY} A 100 100 0 ${largeArc} 1 ${endX} ${endY} Z`);
            path.setAttribute('class', 'wheel-slice dynamic-wheel-elem');
            path.style.fill = 'var(--section-bg, rgba(100,100,100,0.15))';
            path.style.stroke = 'var(--border, #666)';
            svg.insertBefore(path, svg.firstChild);

            // Draw Sector Number Labels
            let midAngle = start + ((end < start ? end + 360 : end) - start) / 2;
            const midX = 35 * Math.sin(midAngle * Math.PI / 180);
            const midY = -35 * Math.cos(midAngle * Math.PI / 180);
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', midX); text.setAttribute('y', midY);
            text.setAttribute('class', 'wheel-label dynamic-wheel-elem');
            text.style.fill = 'var(--text, #fff)';
            text.textContent = i + 1;
            svg.appendChild(text);
        }
    }

    // Draw Handles
    if (wheelSectors.length > 1) {
        wheelSectors.forEach((angle, idx) => {
            const hX = 100 * Math.sin(angle * Math.PI / 180);
            const hY = -100 * Math.cos(angle * Math.PI / 180);
            
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', 0); line.setAttribute('y1', 0);
            line.setAttribute('x2', hX); line.setAttribute('y2', hY);
            line.setAttribute('class', 'wheel-handle dynamic-wheel-elem');
            line.style.stroke = 'var(--primary, #478df5)';
            line.style.strokeWidth = '4';

            // Radial pill background
            const midR = 66; 
            const tX = midR * Math.sin(angle * Math.PI / 180);
            const tY = -midR * Math.cos(angle * Math.PI / 180);
            
            const pill = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            pill.setAttribute('x', tX - 18); 
            pill.setAttribute('y', tY - 9);  
            pill.setAttribute('width', '36');
            pill.setAttribute('height', '18');
            pill.setAttribute('rx', '4');    
            pill.setAttribute('class', 'dynamic-wheel-elem');
            pill.style.fill = 'var(--card, #242526)';
            pill.style.stroke = 'var(--border, #3e4042)';
            pill.style.strokeWidth = '1';
            pill.style.pointerEvents = 'none';

            // Radial text over the pill
            const radialLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            radialLabel.setAttribute('x', tX);
            radialLabel.setAttribute('y', tY); 
            radialLabel.setAttribute('class', 'wheel-label dynamic-wheel-elem');
            radialLabel.style.fill = 'var(--primary, #478df5)';
            radialLabel.style.fontFamily = 'monospace';
            radialLabel.style.fontSize = '10px';
            radialLabel.style.fontWeight = 'bold';
            radialLabel.style.textAnchor = 'middle';       
            radialLabel.style.dominantBaseline = 'middle'; 
            radialLabel.style.stroke = '#000000';          
            radialLabel.style.strokeWidth = '1.5px';       
            radialLabel.style.paintOrder = 'stroke fill';  
            radialLabel.style.pointerEvents = 'none'; 
            
            let displayAngle = Math.round(angle);
            if (displayAngle === 0) displayAngle = 360;
            radialLabel.textContent = displayAngle.toString().padStart(3, '0') + '°';
            
            // --- FIX: Persist active visual state natively during re-renders ---
            const isActive = (draggingHandle === idx);

            const rimNode = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            rimNode.setAttribute('cx', hX);
            rimNode.setAttribute('cy', hY);
            rimNode.setAttribute('r', isActive ? '8' : '6');
            rimNode.setAttribute('class', 'dynamic-wheel-elem');
            rimNode.style.fill = isActive ? 'var(--dispatch, #f39c12)' : '#ffffff';
            rimNode.style.stroke = isActive ? 'var(--dispatch, #f39c12)' : 'var(--primary, #478df5)';
            rimNode.style.strokeWidth = '2.5';
            rimNode.style.transition = 'all 0.1s ease';
            rimNode.style.pointerEvents = 'none'; 
            
            const hitbox = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            hitbox.setAttribute('x1', 0); hitbox.setAttribute('y1', 0);
            hitbox.setAttribute('x2', hX); hitbox.setAttribute('y2', hY);
            hitbox.setAttribute('class', 'wheel-handle-hitbox dynamic-wheel-elem');
            hitbox.style.stroke = 'rgba(255, 255, 255, 0)'; 
            hitbox.style.strokeWidth = '24'; // Slightly thicker to catch fast mouse movements
            hitbox.style.cursor = isActive ? 'grabbing' : 'grab';
            
            hitbox.addEventListener('pointerenter', () => {
                if (draggingHandle === null) {
                    rimNode.style.fill = 'var(--primary, #478df5)';
                    rimNode.setAttribute('r', '8');
                }
            });
            hitbox.addEventListener('pointerleave', () => {
                if (draggingHandle !== idx) {
                    rimNode.style.fill = '#ffffff';
                    rimNode.setAttribute('r', '6');
                }
            });
            
            hitbox.onpointerdown = (e) => { 
                draggingHandle = idx; 
                e.preventDefault(); 
                updateWheel(); // Force an immediate redraw to show the orange active state
            };
            
            svg.appendChild(line);
            svg.appendChild(pill);
            svg.appendChild(radialLabel); 
            svg.appendChild(rimNode); 
            svg.appendChild(hitbox);  
        });
    }
    
    // Draw Center Identifier Rectangle
    const centerMode = document.querySelector('input[name="centerMode"]:checked').value;
    let centerText = "";
    if (centerMode === 'faa') {
        const faaInput = document.getElementById('centerpoint');
        if (faaInput) centerText = faaInput.value.toUpperCase().trim();
    } else {
        const customInput = document.getElementById('customLabel');
        if (customInput) centerText = customInput.value.toUpperCase().trim();
    }
    
    if (centerText) {
        const boxW = 48; 
        const boxH = 18;
        const centerBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        centerBg.setAttribute('x', -(boxW / 2));
        centerBg.setAttribute('y', -(boxH / 2));
        centerBg.setAttribute('width', boxW);
        centerBg.setAttribute('height', boxH);
        centerBg.setAttribute('rx', '4'); 
        centerBg.setAttribute('class', 'dynamic-wheel-elem');
        centerBg.style.fill = 'var(--card, #242526)';
        centerBg.style.stroke = 'var(--border, #3e4042)';
        centerBg.style.strokeWidth = '1.5';
        
        const centerLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        centerLabel.setAttribute('x', '0');
        centerLabel.setAttribute('y', '1.5'); 
        centerLabel.setAttribute('class', 'dynamic-wheel-elem');
        centerLabel.style.fill = 'var(--text, #fff)';
        centerLabel.style.fontFamily = 'monospace';
        centerLabel.style.fontSize = '10px';
        centerLabel.style.fontWeight = 'bold';
        centerLabel.style.textAnchor = 'middle';
        centerLabel.style.dominantBaseline = 'middle';
        centerLabel.style.pointerEvents = 'none'; 
        centerLabel.textContent = centerText.substring(0, 6); 
        
        svg.appendChild(centerBg);
        svg.appendChild(centerLabel);
    }
    
    const btnRem = document.getElementById('btn-rem-sector');
    if (btnRem) btnRem.disabled = wheelSectors.length <= 1;
    
    const btnAdd = document.getElementById('btn-add-sector');
    if (btnAdd) btnAdd.disabled = wheelSectors.length >= 4;
}

function addSectorHandle() {
    if (wheelSectors.length >= 4) return;
    let newCount = wheelSectors.length + 1;
    // Divide 360 degrees by the new amount of sectors and reset the wheel
    wheelSectors = Array.from({length: newCount}, (_, i) => i * (360 / newCount));
    updateWheel(); 
    triggerLiveUpdate();
}

function removeSectorHandle() {
    if (wheelSectors.length <= 1) return;
    let newCount = wheelSectors.length - 1;
    // Divide 360 degrees by the new amount of sectors and reset the wheel
    wheelSectors = Array.from({length: newCount}, (_, i) => i * (360 / newCount));
    updateWheel(); 
    triggerLiveUpdate();
}

// Initialize wheel and sync UI state on load
document.addEventListener('DOMContentLoaded', () => { 
    const mode = document.querySelector('input[name="sectorMode"]:checked').value;
    document.getElementById('sectorUI').style.display = mode === 'custom' ? 'block' : 'none';
    setTimeout(updateWheel, 500); 
});

// --- MAP PREVIEW INTEGRATION ---
let leafletMap = null, previewLayerGroup = null;
let layers = {}, activeBase = 'street';

function showMapPreview() {
    if (!currentCalc || !currentCalc.sectors) {
        alert("Please allow calculations to complete before opening the map.");
        return;
    }

    document.getElementById('mapOverlay').style.display = 'block';
    
    if (!leafletMap) {
        leafletMap = L.map('map', { zoomControl: false, attributionControl: false }).setView([39.8, -98.5], 4);
        
        layers = {
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 20 }),
            street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(leafletMap),
            sat: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'),
            vfr: L.tileLayer('https://tiles.arcgis.com/tiles/ssFJjBXIUyZDrSYZ/arcgis/rest/services/VFR_Sectional/MapServer/tile/{z}/{y}/{x}', {maxZoom: 12})
        };
        previewLayerGroup = L.featureGroup().addTo(leafletMap);
    }
    
    leafletMap.invalidateSize(); 
    previewLayerGroup.clearLayers();

    // Helper to generate polygon arc points for Leaflet
    function getSectorPolygon(lat, lon, radiusNM, startBrg, endBrg) {
        let points = [[lat, lon]];
        const R = 3440.065; 
        const d = radiusNM / R;
        const lat1 = lat * Math.PI / 180;
        const lon1 = lon * Math.PI / 180;
        let end = endBrg;
        if (end <= startBrg && !(startBrg === 0 && endBrg === 360)) end += 360;

        // Loop up to the end minus a tiny epsilon to prevent floating point overshoots
        for (let b = startBrg; b < end - 0.001; b += 2) {
            let brg = (b % 360) * Math.PI / 180;
            let lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(brg));
            let lon2 = lon1 + Math.atan2(Math.sin(brg)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
            points.push([lat2 * 180 / Math.PI, lon2 * 180 / Math.PI]);
        }
        
        // Force the absolute final exact point to seal the pie slice
        let finalBrg = (end % 360) * Math.PI / 180;
        let finalLat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(finalBrg));
        let finalLon2 = lon1 + Math.atan2(Math.sin(finalBrg)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(finalLat2));
        points.push([finalLat2 * 180 / Math.PI, finalLon2 * 180 / Math.PI]);
        
        return points;
    }

    // Draw sectors and their specific markers
    const colors = ['#478df5', '#9b59b6', '#f39c12', '#1abc9c'];
    
    currentCalc.sectors.forEach((secData, idx) => {
        let sColor = colors[idx % colors.length];
        
        // 1. Draw Sector Boundary
        let midAngle = 0;
        if (secData.sector.start === 0 && secData.sector.end === 360) {
            L.circle([currentCalc.center.lat, currentCalc.center.lon], {
                radius: currentCalc.radius * 1852,
                color: sColor, fill: true, fillOpacity: 0.15, weight: 4
            }).addTo(previewLayerGroup);
            midAngle = 360; 
        } else {
            // NEW: Use trueSector to draw polygons accurately on Leaflet's True North map
            let polyPoints = getSectorPolygon(currentCalc.center.lat, currentCalc.center.lon, currentCalc.radius, secData.trueSector.start, secData.trueSector.end);
            L.polygon(polyPoints, {
                color: sColor, fill: true, fillOpacity: 0.15, weight: 4
            }).addTo(previewLayerGroup);
            
            // NEW: Calculate the midpoint using True North to place the floating label in the correct physical spot
            let s = secData.trueSector.start;
            let e = secData.trueSector.end;
            if (e <= s) e += 360;
            midAngle = s + (e - s) / 2;
        }

        // 1.5 Add Floating Sector Label
        // Calculate a coordinate halfway between the centerpoint and the radius edge
        const d = (currentCalc.radius / 2) / 3440.065;
        const brg = midAngle * Math.PI / 180;
        const lat1 = currentCalc.center.lat * Math.PI / 180;
        const lon1 = currentCalc.center.lon * Math.PI / 180;
        let lat2 = Math.asin(Math.sin(lat1)*Math.cos(d) + Math.cos(lat1)*Math.sin(d)*Math.cos(brg));
        let lon2 = lon1 + Math.atan2(Math.sin(brg)*Math.sin(d)*Math.cos(lat1), Math.cos(d)-Math.sin(lat1)*Math.sin(lat2));
        
        // Create a custom HTML label that ignores mouse clicks and has a high-contrast stroke
        let labelHtml = `<div style="color: ${sColor}; font-weight: bold; text-align: center; font-size: 14px; text-shadow: -1px -1px 0 #18191a, 1px -1px 0 #18191a, -1px 1px 0 #18191a, 1px 1px 0 #18191a; pointer-events: none; width: 120px; transform: translate(-50%, -50%);">
            ${currentCalc.sectors.length > 1 ? 'SECTOR ' + (idx + 1) + '<br>' : ''}MSA ${secData.finalMSA}'
        </div>`;
        
        L.marker([lat2 * 180 / Math.PI, lon2 * 180 / Math.PI], {
            icon: L.divIcon({ className: '', html: labelHtml, iconSize: [0,0] }),
            interactive: false // Crucial: allows clicks to pass through to the terrain/obstacle markers below
        }).addTo(previewLayerGroup);

        // 2. Draw Terrain (Green if safe, Red if controlling)
        if (secData.terr && secData.terr.msl > 0) {
            let terrColor = secData.isObs ? '#28a745' : '#fb6161';
            let terrWeight = secData.isObs ? 5 : 8;
            L.circleMarker([secData.terr.lat, secData.terr.lon], {
                radius: terrWeight, color: terrColor, fillColor: terrColor, fillOpacity: 1, weight: 2
            }).bindPopup(`<b>Sector ${idx+1} (${secData.sector.label}) Terrain ${!secData.isObs ? '(CONTROLLING)' : ''}</b><br>${Math.round(secData.terr.msl)} MSL`).addTo(previewLayerGroup);
        }

        // 3. Draw Obstacle (Orange if safe, Red if controlling)
        if (secData.maxObs && secData.maxObs.msl > 0) {
            let obsColor = secData.isObs ? '#fb6161' : '#f39c12';
            let obsWeight = secData.isObs ? 8 : 5;
            L.circleMarker([secData.maxObs.lat, secData.maxObs.lon], {
                radius: obsWeight, color: obsColor, fillColor: obsColor, fillOpacity: 1, weight: 2
            }).bindPopup(`<b>Sector ${idx+1} (${secData.sector.label}) Obstacle ${secData.isObs ? '(CONTROLLING)' : ''}</b><br>${secData.maxObs.msl} MSL`).addTo(previewLayerGroup);
        }

        // 3.5 Draw Boundary Degree Markers (only if custom sectors exist)
        if (currentCalc.sectors.length > 1) {
            // Push the label 10% outside the radius so it doesn't overlap the boundary line
            const dOut = (currentCalc.radius * 1.1) / 3440.065;
            const degBrg = secData.trueSector.start * Math.PI / 180;
            const cLat = currentCalc.center.lat * Math.PI / 180;
            const cLon = currentCalc.center.lon * Math.PI / 180;
            
            let degLat = Math.asin(Math.sin(cLat)*Math.cos(dOut) + Math.cos(cLat)*Math.sin(dOut)*Math.cos(degBrg));
            let degLon = cLon + Math.atan2(Math.sin(degBrg)*Math.sin(dOut)*Math.cos(cLat), Math.cos(dOut)-Math.sin(cLat)*Math.sin(degLat));
            
            let displayDeg = Math.round(secData.sector.start) === 0 ? 360 : Math.round(secData.sector.start);
            
            // Explicitly centering text inside a fixed 40x20 pixel box
            let degHtml = `<div style="color: #fff; font-weight: 900; font-size: 14px; font-family: monospace; text-shadow: -1.5px -1.5px 0 #000, 1.5px -1.5px 0 #000, -1.5px 1.5px 0 #000, 1.5px 1.5px 0 #000; text-align: center; line-height: 20px; width: 40px; height: 20px; pointer-events: none;">
                ${displayDeg.toString().padStart(3, '0')}°
            </div>`;
            
            L.marker([degLat * 180 / Math.PI, degLon * 180 / Math.PI], {
                // iconSize and iconAnchor strictly force the dead-center of the text to lock onto the coordinate
                icon: L.divIcon({ className: '', html: degHtml, iconSize: [40, 20], iconAnchor: [20, 10] }),
                interactive: false
            }).addTo(previewLayerGroup);
        }
    });

    // 4. Draw Centerpoint (Always on top)
    L.circleMarker([currentCalc.center.lat, currentCalc.center.lon], {
        radius: 6, color: '#ffffff', fillColor: '#478df5', fillOpacity: 1, weight: 2
    }).bindPopup(`<b>${currentCalc.center.name}</b><br>Radius: ${currentCalc.radius} NM`).addTo(previewLayerGroup);

    // Auto-fit to the radius boundary
    if (previewLayerGroup.getLayers().length > 0) {
        leafletMap.fitBounds(previewLayerGroup.getBounds(), {padding: [20, 20], maxZoom: 12});
    }
}

function hideMap() { document.getElementById('mapOverlay').style.display = 'none'; }
function toggleMaximize() { document.getElementById('mapOverlay').classList.toggle('maximized'); setTimeout(() => leafletMap.invalidateSize(), 400); }

function setBaseView(type) {
    if (layers[activeBase]) leafletMap.removeLayer(layers[activeBase]);
    layers[type].addTo(leafletMap).bringToBack();
    activeBase = type;

    document.querySelectorAll('.layer-switch .layer-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('b-' + type).classList.add('active');
}

function generateKneeboard() {
    if (!currentCalc || !currentCalc.sectors) {
        alert("Please calculate an MSA before generating a kneeboard card.");
        return;
    }

    // 1. Determine Location Identifier
    const centerMode = document.querySelector('input[name="centerMode"]:checked').value;
    let displayLoc = centerMode === 'faa' ? document.getElementById('centerpoint').value.toUpperCase() : document.getElementById('customLabel').value.toUpperCase();
    if (!displayLoc) displayLoc = "LOCAL";

    // 2. Calculate Expiration (Synced to 56-day FAA DOF Cycle)
    const baseDof = new Date(Date.UTC(2024, 2, 21)); // Known 56-day FAA Epoch (March 21, 2024)
    const now = new Date();
    const diffDays = Math.floor((now - baseDof) / (1000 * 60 * 60 * 24));
    const cyclesPassed = Math.floor(diffDays / 56);
    
    // Expiration is the start date of the NEXT 56-day cycle
    const d = new Date(baseDof.getTime() + ((cyclesPassed + 1) * 56 * 24 * 60 * 60 * 1000));
    const months = ["JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"];
    // Force UTC extraction to prevent local timezone shifts (e.g., EST pushing midnight UTC back a day)
    const expDate = `${d.getUTCDate().toString().padStart(2, '0')} ${months[d.getUTCMonth()]} ${d.getUTCFullYear().toString().slice(-2)}`;

    // 3. Determine Field Values
    let msaVal;
    if (currentCalc.sectors.length > 1) {
        let highest = Math.max(...currentCalc.sectors.map(s => s.finalMSA));
        msaVal = `${highest}' MSL (MAX)`;
    } else {
        msaVal = `${currentCalc.sectors[0].finalMSA}' MSL`;
    }

    // 4. Populate Static Header
    document.getElementById('print-loc-1').innerText = displayLoc;
    document.getElementById('print-exp-1').innerText = expDate;
    document.querySelector('.print-title').innerHTML = `IIMC procedure for ${currentCalc.radius} NM radius.<br>MSA chart oriented to MAG N`;

    // 5. Handle Diagram Injection
    const wheelContainer = document.getElementById('print-wheel-1');
    const freqBox = document.querySelector('.print-freq-box');
    wheelContainer.innerHTML = ''; 
    
    if (currentCalc.sectors.length === 1) {
        freqBox.style.display = 'none'; // Hide the floating HTML box
        freqBox.innerHTML = ''; 
        
        // Exact match to multi-sector wrapper proportions
        wheelContainer.style.width = "100%"; 
        wheelContainer.style.height = "100%";
        wheelContainer.style.border = "none"; 
        wheelContainer.style.borderRadius = "0"; // Removes the pure CSS circle
        
        const artccMap = {"ZAB":"Albuquerque","ZAN":"Anchorage","ZAU":"Chicago","ZBW":"Boston","ZDC":"Washington","ZDV":"Denver","ZFW":"Fort Worth","ZHU":"Houston","ZID":"Indianapolis","ZJX":"Jacksonville","ZKC":"Kansas City","ZLA":"Los Angeles","ZLC":"Salt Lake","ZMA":"Miami","ZME":"Memphis","ZMP":"Minneapolis","ZNY":"New York","ZOA":"Oakland","ZOB":"Cleveland","ZSE":"Seattle","ZTL":"Atlanta","ZSU":"San Juan","ZUA":"Guam","ZHN":"Honolulu"};
        let bestPri = currentCalc.sectors[0].bestPri;
        let bestCtr = currentCalc.sectors[0].bestCtr;
        let appName = bestPri ? bestPri.name.toUpperCase() : "NONE";
        let appFreq = bestPri && bestPri.primary_freq !== "None" ? bestPri.primary_freq : "N/A";
        let ctrName = bestCtr ? (artccMap[bestCtr.center_id] || bestCtr.center_id).toUpperCase() + " CTR" : "NONE CTR";
        let ctrFreq = bestCtr && bestCtr.center_freq !== "None" ? bestCtr.center_freq : "N/A";

        // Exact 1:1 match of the multi-sector SVG viewBox, radius, and frequency box embedding
        wheelContainer.innerHTML = `
            <svg viewBox="-320 -320 640 640" style="width: 100%; height: 100%; overflow: visible; font-family: Arial, sans-serif;">
                <circle cx="0" cy="0" r="250" fill="none" stroke="#555" stroke-width="6" />
                
                <foreignObject class="draggable-box freq-box" x="150" y="-315" width="165" height="95" overflow="visible">
                    <div xmlns="http://www.w3.org/1999/xhtml" style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: transparent;">
                        <div class="editable-text" style="box-sizing: border-box; display: inline-flex; flex-direction: column; justify-content: center; font-family: Arial, sans-serif; font-size: 14px; line-height: 1.1; text-align: center; border: 2px solid #000; padding: 4px; background: #fff; white-space: nowrap; cursor: pointer;" contenteditable="false">
                            <div style="font-weight: 900; text-decoration: underline;">${appName}</div>
                            <div style="font-weight: bold; margin-bottom: 2px;">APP: ${appFreq}</div>
                            <div style="font-weight: 900; text-decoration: underline;">${ctrName}</div>
                            <div style="font-weight: bold;">${ctrFreq}</div>
                        </div>
                    </div>
                </foreignObject>

                <foreignObject x="-200" y="-80" width="400" height="160" overflow="visible">
                    <div xmlns="http://www.w3.org/1999/xhtml" style="width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: transparent;">
                        <div id="print-center-label-1" class="editable-text" style="font-size: 64px; font-weight: 900; line-height: 1.1; text-align: center; color: #000; cursor: pointer;" contenteditable="false">${displayLoc}</div>
                        <div class="editable-text" style="font-size: 48px; font-weight: 900; line-height: 1.1; text-align: center; color: #000; white-space: nowrap; cursor: pointer;" contenteditable="false">MSA: <span id="print-msa-1" style="font-size: inherit;">${msaVal}</span></div>
                    </div>
                </foreignObject>
            </svg>
        `;
    } else {
        freqBox.style.display = 'none'; 
        wheelContainer.style.width = "100%"; 
        wheelContainer.style.height = "100%"; 
        wheelContainer.style.border = "none"; 
        
        // Retaining the stable 250px wheel radius
        let innerSVG = `<circle cx="0" cy="0" r="250" fill="none" stroke="#555" stroke-width="6" />`;
            
        // 1. Draw all sector dividers, MSA labels, and degree labels
        currentCalc.sectors.forEach((secData) => {
            let start = secData.sector.start;
            let end = secData.sector.end;
            if (end <= start) end += 360;
            let angleDiff = end - start;
            let midAngle = start + angleDiff / 2;
            
            let msaFontSize = angleDiff <= 45 ? 24 : (angleDiff <= 75 ? 32 : 46);
            // TWEAK: Pulled the default rendering radius much closer to the center of the 250px circle
            let textRad = angleDiff <= 45 ? 150 : (angleDiff <= 75 ? 135 : 125);
            let tX = textRad * Math.sin(midAngle * Math.PI / 180);
            let tY = -textRad * Math.cos(midAngle * Math.PI / 180);
            
            // TWEAK: Added msa-box class and overflow: visible for the slider engine. Removed manual resize.
            let msaW = 140;
            let msaH = 60;
            let msaX = tX - (msaW / 2);
            let msaY = tY - (msaH / 2);
            
            innerSVG += `<foreignObject class="draggable-box msa-box" x="${msaX}" y="${msaY}" width="${msaW}" height="${msaH}" overflow="visible">
                <div class="editable-text" xmlns="http://www.w3.org/1999/xhtml" style="box-sizing: border-box; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; font-family: Arial, sans-serif; font-size: ${msaFontSize}px; font-weight: 900; color: #000; text-align: center; background: transparent;" contenteditable="false">
                    ${secData.finalMSA}'
                </div>
            </foreignObject>`;

            let startX = 250 * Math.sin(start * Math.PI / 180);
            let startY = -250 * Math.cos(start * Math.PI / 180);
            innerSVG += `<line x1="0" y1="0" x2="${startX}" y2="${startY}" stroke="#555" stroke-width="4" />`;
            
            let degRad = 270; 
            let dX = degRad * Math.sin(start * Math.PI / 180);
            let dY = -degRad * Math.cos(start * Math.PI / 180);
            let displayDeg = Math.round(start) === 0 ? 360 : Math.round(start);
            innerSVG += `<text x="${dX}" y="${dY}" data-angle="${start}" text-anchor="middle" dominant-baseline="central" font-size="18" font-weight="900" fill="#000" stroke="#fff" stroke-width="4" paint-order="stroke">${displayDeg.toString().padStart(3, '0')}°</text>`;
        });

        // 2. Map sectors to Absolute Extreme Corners
        const artccMap = {"ZAB":"Albuquerque","ZAN":"Anchorage","ZAU":"Chicago","ZBW":"Boston","ZDC":"Washington","ZDV":"Denver","ZFW":"Fort Worth","ZHU":"Houston","ZID":"Indianapolis","ZJX":"Jacksonville","ZKC":"Kansas City","ZLA":"Los Angeles","ZLC":"Salt Lake","ZMA":"Miami","ZME":"Memphis","ZMP":"Minneapolis","ZNY":"New York","ZOA":"Oakland","ZOB":"Cleveland","ZSE":"Seattle","ZTL":"Atlanta","ZSU":"San Juan","ZUA":"Guam","ZHN":"Honolulu"};
        
        let sortedSectors = currentCalc.sectors.map(secData => {
            let start = secData.sector.start;
            let end = secData.sector.end;
            if (end <= start) end += 360;
            return { secData, midAngle: (start + (end - start) / 2) % 360 };
        });

        let foWidth = 165; 
        let foHeight = 95; 
        
        let corners = [
            { id: 'TR', x: 150, y: -315, align: 'left', used: false },
            { id: 'BR', x: 150, y: 220, align: 'left', used: false },
            { id: 'BL', x: -315, y: 220, align: 'right', used: false },
            { id: 'TL', x: -315, y: -315, align: 'right', used: false }
        ];

        sortedSectors.forEach(item => {
            let m = item.midAngle;
            let pref = [];
            if (m >= 0 && m < 90) pref = ['TR', 'BR', 'TL', 'BL'];
            else if (m >= 90 && m < 180) pref = ['BR', 'TR', 'BL', 'TL'];
            else if (m >= 180 && m < 270) pref = ['BL', 'TL', 'BR', 'TR'];
            else pref = ['TL', 'BL', 'TR', 'BR'];

            for (let p of pref) {
                let corner = corners.find(c => c.id === p);
                if (!corner.used) {
                    item.corner = corner;
                    corner.used = true;
                    break;
                }
            }
            
            let cX = item.corner.x;
            let cY = item.corner.y;
            
            // Fix the initial gap and bisection perfectly inside the string generator
            let targetX = cX + (foWidth / 2);
            let targetY = cY + (foHeight / 2);

            // Calculate the angle from the center (0,0) to the box's center
            let angle = Math.atan2(targetY, targetX);
            
            // Slide the start of the line to the correct edge of the 250px circle
            let lineStartX = 250 * Math.cos(angle);
            let lineStartY = 250 * Math.sin(angle);
            
            let lineId = `leader-line-${item.corner.id}`;
            innerSVG += `<line id="${lineId}" x1="${lineStartX}" y1="${lineStartY}" x2="${targetX}" y2="${targetY}" stroke="#555" stroke-width="1.5" />`;
            
            let appName = item.secData.bestPri ? item.secData.bestPri.name.toUpperCase() : "NONE";
            let appFreq = item.secData.bestPri && item.secData.bestPri.primary_freq !== "None" ? item.secData.bestPri.primary_freq : "N/A";
            let ctrName = item.secData.bestCtr ? (artccMap[item.secData.bestCtr.center_id] || item.secData.bestCtr.center_id).toUpperCase() + " CTR" : "NONE CTR";
            let ctrFreq = item.secData.bestCtr && item.secData.bestCtr.center_freq !== "None" ? item.secData.bestCtr.center_freq : "N/A";
            
            // TWEAK: Wrapped the editable-text to make the white background and border tightly hug the text, ignoring the invisible foreignObject boundaries.
            innerSVG += `<foreignObject class="draggable-box freq-box" x="${cX}" y="${cY}" width="${foWidth}" height="${foHeight}" data-line="${lineId}" overflow="visible">
                <div xmlns="http://www.w3.org/1999/xhtml" style="width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background: transparent;">
                    <div class="editable-text" style="box-sizing: border-box; display: inline-flex; flex-direction: column; justify-content: center; font-family: Arial, sans-serif; font-size: 14px; line-height: 1.1; text-align: center; border: 2px solid #000; padding: 4px; background: #fff; white-space: nowrap;" contenteditable="false">
                        <div style="font-weight: 900; text-decoration: underline;">${appName}</div>
                        <div style="font-weight: bold;">APP: ${appFreq}</div>
                        <div style="font-weight: 900; text-decoration: underline; margin-top: 2px;">${ctrName}</div>
                        <div style="font-weight: bold;">${ctrFreq}</div>
                    </div>
                </div>
            </foreignObject>`;
        });
        
        let boxWidth = Math.max(54, displayLoc.length * 16 + 18);
        let boxHeight = 34; 
        let rectX = -(boxWidth / 2);
        let rectY = -(boxHeight / 2);
        
        innerSVG += `
            <rect x="${rectX}" y="${rectY}" width="${boxWidth}" height="${boxHeight}" rx="4" fill="#fff" stroke="#555" stroke-width="3" />
            <text x="0" y="0" text-anchor="middle" dominant-baseline="central" font-size="24" font-weight="900" fill="#000">${displayLoc}</text>
        `;
        
        // Retaining the stable 640x640 Square ViewBox
        wheelContainer.innerHTML = `<svg viewBox="-320 -320 640 640" style="width: 100%; height: 100%; overflow: visible; font-family: Arial, sans-serif;">${innerSVG}</svg>`;
    }

    // 6. Display the Print Preview instead of printing immediately
    togglePrintLogo(); 
    document.body.classList.add('preview-mode');
    
    // Auto-open the customize sidebar
    document.body.classList.add('is-customizing');
    
    // Toggle customization sliders based on card type
    const customSliders = document.getElementById('customization-sliders');
    if (customSliders) {
        customSliders.style.display = currentCalc.sectors.length > 1 ? 'block' : 'none';
    }
    
    // Toggle multi-sector controls based on card type
    const multiControls = document.getElementById('multi-sector-only-controls');
    if (multiControls) {
        multiControls.style.display = currentCalc.sectors.length > 1 ? 'block' : 'none';
    }
    
    // Make SVG text boxes editable automatically
    document.querySelectorAll('.editable-text').forEach(el => {
        el.setAttribute('contenteditable', 'true');
    });
    
    // Reset all sliders to defaults on fresh generation
    ['msa', 'freq', 'deg', 'degDist'].forEach(type => {
        let slider = document.getElementById(`slider-${type}-scale`);
        let valObj = document.getElementById(`val-${type}-scale`);
        if(slider) {
            if (type === 'degDist') {
                slider.value = 270;
                if(valObj) valObj.innerText = "270px";
            } else {
                slider.value = 1.0;
                if(valObj) valObj.innerText = "1.00x";
            }
        }
    });

    // 7. Auto-Refresh Duplicate Layout if active
    const activeLayoutBtn = document.querySelector('.active-layout-btn');
    if (activeLayoutBtn && activeLayoutBtn.innerText.includes('Duplicate')) {
        document.getElementById('notes-side').innerHTML = document.getElementById('card-side').innerHTML;
    }

    // 8. Apply Pending Template Layout (if the user loaded one)
    if (window.pendingTemplateLayout) {
        const t = window.pendingTemplateLayout;
        const wheelSvg = document.getElementById('print-wheel-1');
        
        // Apply saved custom text
        if (t.text) {
            const titleEl = document.querySelector('.print-title');
            const instEl = document.querySelector('.print-instructions-section');
            if (titleEl && t.text.title) titleEl.innerHTML = t.text.title;
            if (instEl && t.text.instructions) instEl.innerHTML = t.text.instructions;
        }

        // Apply saved Logo Settings
        if (t.logo) {
            const logoToggle = document.getElementById('toggle-logo-btn');
            const logoSelect = document.getElementById('logo-selector');
            if (logoToggle) logoToggle.checked = t.logo.enabled;
            if (logoSelect && t.logo.url) logoSelect.value = t.logo.url;
            if (typeof togglePrintLogo === 'function') togglePrintLogo();
            if (typeof updateLogoImage === 'function') updateLogoImage();
        }

        // Apply saved Sliders (and trigger their visual scaling)
        if (t.sliders) {
            ['msa', 'freq', 'deg', 'degDist'].forEach(type => {
                let slider = document.getElementById(`slider-${type}-scale`);
                if (slider && t.sliders[type]) {
                    slider.value = t.sliders[type];
                    // Trigger the scaling visually
                    if (typeof applyScale === 'function') applyScale(type, parseFloat(t.sliders[type]));
                    let valObj = document.getElementById(`val-${type}-scale`);
                    if(valObj) {
                        if(type === 'degDist') valObj.innerText = Math.round(t.sliders[type]) + "px";
                        else valObj.innerText = parseFloat(t.sliders[type]).toFixed(2) + "x";
                    }
                }
            });
        }

        // Snap boxes to saved X/Y positions and reconnect rubber-band lines
        if (t.positions && wheelSvg) {
            const msaBoxes = wheelSvg.querySelectorAll('.msa-box');
            const freqBoxes = wheelSvg.querySelectorAll('.freq-box');
            
            t.positions.msa.forEach((pos, i) => {
                if (msaBoxes[i]) {
                    msaBoxes[i].setAttribute('x', pos.x);
                    msaBoxes[i].setAttribute('y', pos.y);
                }
            });
            
            t.positions.freq.forEach((pos, i) => {
                if (freqBoxes[i]) {
                    freqBoxes[i].setAttribute('x', pos.x);
                    freqBoxes[i].setAttribute('y', pos.y);
                    
                    let lineId = freqBoxes[i].getAttribute('data-line');
                    let line = document.getElementById(lineId);
                    if (line) {
                        let w = parseFloat(freqBoxes[i].getAttribute('width'));
                        let h = parseFloat(freqBoxes[i].getAttribute('height'));
                        let boxCenterX = parseFloat(pos.x) + (w / 2);
                        let boxCenterY = parseFloat(pos.y) + (h / 2);
                        
                        line.setAttribute('x2', boxCenterX);
                        line.setAttribute('y2', boxCenterY);
                        
                        let currentX1 = parseFloat(line.getAttribute('x1'));
                        let currentY1 = parseFloat(line.getAttribute('y1'));
                        let radius = Math.sqrt(currentX1 * currentX1 + currentY1 * currentY1);
                        let angle = Math.atan2(boxCenterY, boxCenterX);
                        
                        line.setAttribute('x1', radius * Math.cos(angle));
                        line.setAttribute('y1', radius * Math.sin(angle));
                    }
                }
            });
        }
        
        // Clear the pending layout so it doesn't accidentally apply to future resets
        window.pendingTemplateLayout = null;
    }
}

// NEW: Function to close the preview and return to the UI
function closePreview() {
    document.body.classList.remove('preview-mode');
    document.body.classList.remove('is-customizing');
}

// --- NEW: CUSTOMIZE MODE LOGIC ---
const svgResizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
        let fo = entry.target.closest('foreignObject');
        if (fo) {
            // Force the SVG container to match the dimensions of the user-resized inner div
            fo.setAttribute('width', entry.target.offsetWidth);
            fo.setAttribute('height', entry.target.offsetHeight);
        }
    }
});

// Slider Scaling Engine for SVG Elements
function applyScale(type, scaleValue) {
    // --- Handle Single-Sector HTML Elements ---
    if (window.currentCalc && window.currentCalc.sectors && window.currentCalc.sectors.length === 1) {
        if (type === 'msa') {
            const msaContainer = document.querySelector('.print-center-text');
            if (msaContainer) {
                // Scale both the ID label and the MSA value proportionally
                msaContainer.querySelectorAll('div').forEach(el => {
                    if (!el.hasAttribute('data-base-fs')) {
                        el.setAttribute('data-base-fs', parseFloat(window.getComputedStyle(el).fontSize));
                    }
                    let baseFS = parseFloat(el.getAttribute('data-base-fs'));
                    el.style.fontSize = (baseFS * scaleValue) + 'px';
                });
            }
        } else if (type === 'freq') {
            const freqBox = document.querySelector('.print-freq-box');
            if (freqBox) {
                if (!freqBox.hasAttribute('data-base-fs')) {
                    freqBox.setAttribute('data-base-fs', parseFloat(window.getComputedStyle(freqBox).fontSize));
                    freqBox.setAttribute('data-base-pad', parseFloat(window.getComputedStyle(freqBox).padding));
                }
                let baseFS = parseFloat(freqBox.getAttribute('data-base-fs'));
                let basePad = parseFloat(freqBox.getAttribute('data-base-pad'));
                
                freqBox.style.fontSize = (baseFS * scaleValue) + 'px';
                if (!isNaN(basePad)) freqBox.style.padding = (basePad * scaleValue) + 'px';
            }
        }
        return; // Exit early, no SVG processing needed
    }
    // --- End Single-Sector Scaling ---

    const wheel = document.getElementById('print-wheel-1');
    if (!wheel) return;

    // Bypass CSS scaling bugs by mathematically adjusting the physical SVG attributes and font sizes.
    if (type === 'msa' || type === 'freq') {
        let selector = type === 'msa' ? '.msa-box' : '.freq-box';
        wheel.querySelectorAll(selector).forEach(fo => {
            const innerDiv = fo.querySelector('.editable-text');
            if (!innerDiv) return;

            // Cache the original baseline dimensions on the very first slide
            if (!fo.hasAttribute('data-base-w')) {
                fo.setAttribute('data-base-w', fo.getAttribute('width'));
                fo.setAttribute('data-base-h', fo.getAttribute('height'));
                innerDiv.setAttribute('data-base-fs', parseFloat(window.getComputedStyle(innerDiv).fontSize));
            }

            // Calculate perfectly scaled dimensions
            let baseW = parseFloat(fo.getAttribute('data-base-w'));
            let baseH = parseFloat(fo.getAttribute('data-base-h'));
            let baseFS = parseFloat(innerDiv.getAttribute('data-base-fs'));

            // Apply scaling to the invisible bounding box
            fo.setAttribute('width', baseW * scaleValue);
            fo.setAttribute('height', baseH * scaleValue);
            
            // Strip out the previous experimental zoom and apply precise font & padding scaling
            innerDiv.style.zoom = 'normal'; 
            innerDiv.style.fontSize = (baseFS * scaleValue) + 'px';
            innerDiv.style.padding = (4 * scaleValue) + 'px'; // Ensures the border doesn't crowd the text
        });
    } else if (type === 'deg') {
        // Degree markers are native SVG elements and can be scaled directly
        wheel.querySelectorAll('text[stroke="#fff"]').forEach(el => {
            if (!el.hasAttribute('data-base-fs')) {
                el.setAttribute('data-base-fs', parseFloat(window.getComputedStyle(el).fontSize));
            }
            let baseFS = parseFloat(el.getAttribute('data-base-fs'));
            el.style.fontSize = (baseFS * scaleValue) + 'px';
        });
    } else if (type === 'degDist') {
        // Recalculate X and Y based on the slider radius and the stored angle
        wheel.querySelectorAll('text[stroke="#fff"]').forEach(el => {
            let angle = parseFloat(el.getAttribute('data-angle'));
            if (!isNaN(angle)) {
                let dX = scaleValue * Math.sin(angle * Math.PI / 180);
                let dY = -scaleValue * Math.cos(angle * Math.PI / 180);
                el.setAttribute('x', dX);
                el.setAttribute('y', dY);
            }
        });
    }
}

// Attach listeners to the new sidebar sliders
['msa', 'freq', 'deg', 'degDist'].forEach(type => {
    document.addEventListener('input', (e) => {
        if (e.target.id === `slider-${type}-scale`) {
            let val = parseFloat(e.target.value);
            let label = document.getElementById(`val-${type}-scale`);
            if(label) {
                if(type === 'degDist') label.innerText = Math.round(val) + "px";
                else label.innerText = val.toFixed(2) + "x";
            }
            applyScale(type, val);
        }
    });
});

// Auto-enable inline editing for the Title and Instructions when the preview opens
const previewObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class' && document.body.classList.contains('preview-mode')) {
            const instructions = document.querySelector('.print-instructions-section');
            const centerTitle = document.querySelector('.print-title');
            [instructions, centerTitle].forEach(el => {
                if (el) {
                    el.classList.add('editable-text');
                    el.setAttribute('contenteditable', 'true');
                }
            });
        }
    });
});
previewObserver.observe(document.body, { attributes: true });

function togglePrintLogo() {
    const logoBox = document.querySelector('.print-logo-box');
    const titleBox = document.querySelector('.print-title-box');
    const btn = document.getElementById('toggle-logo-btn');
    const dropWrapper = document.getElementById('logo-select-wrapper');
    
    if (btn && btn.checked) {
        logoBox.style.display = 'flex';
        titleBox.style.width = '52%';
        if (dropWrapper) dropWrapper.style.display = 'block';
    } else {
        logoBox.style.display = 'none';
        titleBox.style.width = '70%'; // Reclaim the 18% width from the logo
        if (dropWrapper) dropWrapper.style.display = 'none';
    }
}

// NEW: Instantly update the logo image when a new dropdown option is selected
function updateLogoImage() {
    const selector = document.getElementById('logo-selector');
    const img = document.getElementById('print-logo-img');
    if (selector && img) {
        img.src = selector.value;
    }
}

// SVG Drag Engine (Approach A)
let dragCtx = null;

document.addEventListener('pointerdown', (e) => {
    if (!document.body.classList.contains('is-customizing')) return;
    
    let target = e.target.closest('.draggable-box');
    if (!target) return;

    let svg = target.closest('svg');
    if (!svg) return;

    // Translate screen pixels to SVG coordinate space
    let pt = svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    let cursorPt = pt.matrixTransform(svg.getScreenCTM().inverse());

    let startX = parseFloat(target.getAttribute('x'));
    let startY = parseFloat(target.getAttribute('y'));
    
    let lineId = target.getAttribute('data-line');
    let line = document.getElementById(lineId);
    let lineStartX = line ? parseFloat(line.getAttribute('x2')) : 0;
    let lineStartY = line ? parseFloat(line.getAttribute('y2')) : 0;

    // Store the exact click offset to prevent snapping
    dragCtx = {
        target: target,
        svg: svg,
        offsetX: cursorPt.x - startX,
        offsetY: cursorPt.y - startY,
        line: line,
        lineOffsetX: cursorPt.x - lineStartX,
        lineOffsetY: cursorPt.y - lineStartY
    };
    
    target.style.cursor = 'grabbing';
    document.body.classList.add('is-dragging'); // Hides the hover outline to prevent artifacts
});

document.addEventListener('pointermove', (e) => {
    if (!dragCtx) return;
    e.preventDefault(); // Prevents accidental text highlighting while dragging

    let pt = dragCtx.svg.createSVGPoint();
    pt.x = e.clientX;
    pt.y = e.clientY;
    let cursorPt = pt.matrixTransform(dragCtx.svg.getScreenCTM().inverse());

    let newX = cursorPt.x - dragCtx.offsetX;
    let newY = cursorPt.y - dragCtx.offsetY;
    
    // RED CELL FIX: Hard bounding box clamping to prevent elements dropping off the kneeboard
    let vb = dragCtx.svg.viewBox.baseVal;
    let w = parseFloat(dragCtx.target.getAttribute('width')) || 0;
    let h = parseFloat(dragCtx.target.getAttribute('height')) || 0;
    
    newX = Math.max(vb.x, Math.min(newX, vb.x + vb.width - w));
    newY = Math.max(vb.y, Math.min(newY, vb.y + vb.height - h));

    dragCtx.target.setAttribute('x', newX);
    dragCtx.target.setAttribute('y', newY);

    // Dynamic rubber-band routing to prevent bisection and fix floating ends
    if (dragCtx.line) {
        let w = parseFloat(dragCtx.target.getAttribute('width'));
        let h = parseFloat(dragCtx.target.getAttribute('height'));
        
        // 1. Fix the floating gap: route the line exactly to the center of the box.
        // The solid white background of the text box will cover the overlap perfectly.
        let boxCenterX = newX + (w / 2);
        let boxCenterY = newY + (h / 2);
        dragCtx.line.setAttribute('x2', boxCenterX);
        dragCtx.line.setAttribute('y2', boxCenterY);

        // 2. Prevent center bisection: slide the start of the line around the edge of the circle.
        // First, extract the circle's radius using the line's current starting point coordinates.
        let currentX1 = parseFloat(dragCtx.line.getAttribute('x1'));
        let currentY1 = parseFloat(dragCtx.line.getAttribute('y1'));
        let radius = Math.sqrt(currentX1 * currentX1 + currentY1 * currentY1);

        // Calculate the angle from the center of the diagram (0,0) to the dragged box
        let angle = Math.atan2(boxCenterY, boxCenterX);

        // Update the start of the line to stay anchored to the circle's edge
        dragCtx.line.setAttribute('x1', radius * Math.cos(angle));
        dragCtx.line.setAttribute('y1', radius * Math.sin(angle));
    }
});

document.addEventListener('pointerup', () => {
    if (dragCtx) {
        dragCtx.target.style.cursor = 'grab';
        dragCtx = null;
        document.body.classList.remove('is-dragging'); // Restores the hover outline
    }
});

// --- TEMPLATE SAVE & LOAD ENGINE ---
function saveTemplate() {
    const template = {
        location: {
            mode: document.querySelector('input[name="centerMode"]:checked') ? document.querySelector('input[name="centerMode"]:checked').value : 'faa',
            centerpoint: document.getElementById('centerpoint') ? document.getElementById('centerpoint').value : '',
            lat: document.getElementById('latInput') ? document.getElementById('latInput').value : '',
            lon: document.getElementById('lonInput') ? document.getElementById('lonInput').value : '',
            customLabel: document.getElementById('customLabel') ? document.getElementById('customLabel').value : '',
            radius: document.getElementById('radius') ? document.getElementById('radius').value : '30'
        },
        sectors: {
            customMode: document.getElementById('ui-sector-toggle') ? document.getElementById('ui-sector-toggle').checked : false,
            angles: wheelSectors
        },
        sliders: {
            msa: document.getElementById('slider-msa-scale') ? document.getElementById('slider-msa-scale').value : "1.0",
            freq: document.getElementById('slider-freq-scale') ? document.getElementById('slider-freq-scale').value : "1.0",
            deg: document.getElementById('slider-deg-scale') ? document.getElementById('slider-deg-scale').value : "1.0",
            degDist: document.getElementById('slider-degDist-scale') ? document.getElementById('slider-degDist-scale').value : "270"
        },
        logo: {
            enabled: document.getElementById('toggle-logo-btn') ? document.getElementById('toggle-logo-btn').checked : false,
            url: document.getElementById('logo-selector') ? document.getElementById('logo-selector').value : ""
        },
        text: {
            title: document.querySelector('.print-title') ? document.querySelector('.print-title').innerHTML : "",
            instructions: document.querySelector('.print-instructions-section') ? document.querySelector('.print-instructions-section').innerHTML : ""
        },
        positions: { msa: [], freq: [] }
    };

    const wheelSvg = document.getElementById('print-wheel-1');
    if (wheelSvg) {
        wheelSvg.querySelectorAll('.msa-box').forEach(box => {
            template.positions.msa.push({ x: box.getAttribute('x'), y: box.getAttribute('y') });
        });
        wheelSvg.querySelectorAll('.freq-box').forEach(box => {
            template.positions.freq.push({ x: box.getAttribute('x'), y: box.getAttribute('y') });
        });
    }

    // Generate dynamic filename
    let loc = "";
    const centerMode = document.querySelector('input[name="centerMode"]:checked');
    if (centerMode && centerMode.value === 'faa') {
        const faaInput = document.getElementById('centerpoint');
        if (faaInput) loc = faaInput.value.toUpperCase().trim();
    } else {
        const customInput = document.getElementById('customLabel');
        if (customInput) loc = customInput.value.toUpperCase().trim();
    }
    if (!loc) loc = "LOCAL";

    let rad = "30";
    const radiusInput = document.getElementById('radius');
    if (radiusInput && radiusInput.value) rad = radiusInput.value.trim();

    const d = new Date();
    const dateStr = d.getFullYear() + String(d.getMonth() + 1).padStart(2, '0') + String(d.getDate()).padStart(2, '0');
    const fileName = `${loc}-IIMC_Card-${rad}NM-${dateStr}.json`;

    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(template));
    const dlAnchorElem = document.createElement('a');
    dlAnchorElem.setAttribute("href", dataStr);
    dlAnchorElem.setAttribute("download", fileName);
    document.body.appendChild(dlAnchorElem);
    dlAnchorElem.click();
    dlAnchorElem.remove();
}

async function loadTemplate(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const template = JSON.parse(e.target.result);

            // 1. Restore the saved location parameters
            if (template.location) {
                const modeRadios = document.querySelectorAll('input[name="centerMode"]');
                modeRadios.forEach(r => r.checked = (r.value === template.location.mode));
                if (typeof toggleCenterInput === 'function') toggleCenterInput();
                
                if (document.getElementById('centerpoint')) document.getElementById('centerpoint').value = template.location.centerpoint || '';
                if (document.getElementById('latInput')) document.getElementById('latInput').value = template.location.lat || '';
                if (document.getElementById('lonInput')) document.getElementById('lonInput').value = template.location.lon || '';
                if (document.getElementById('customLabel')) document.getElementById('customLabel').value = template.location.customLabel || '';
                if (document.getElementById('radius')) document.getElementById('radius').value = template.location.radius || '30';
                
                if (typeof updateFacilityName === 'function') updateFacilityName();
            }

            // 2. Restore the saved sector configuration
            if (template.sectors) {
                const toggle = document.getElementById('ui-sector-toggle');
                if (toggle) {
                    toggle.checked = template.sectors.customMode;
                    syncSectors(toggle);
                }
                wheelSectors = template.sectors.angles || [0, 90, 180, 270];
                updateWheel();
            }

            // 3. Safety Check: Ensure we have a location to calculate against
            let centerInput = document.getElementById('centerpoint').value;
            let latInput = document.getElementById('latInput').value;
            if (!centerInput && !latInput) {
                alert("Please enter a location and allow the data to calculate before the layout can be fully applied.");
                event.target.value = '';
                return;
            }

            // 4. Store the layout globally to be applied when the user generates the card
            window.pendingTemplateLayout = template;

            // 5. Force fresh math against the newly loaded sectors and location
            await calculateIIMC();
            
            // 6. Alert the user
            alert("Setup loaded successfully! The MSAs and frequencies have been recalculated for this location based on current data.\n\nPlease verify the data on your screen, then click 'Generate kneeboard' to view your saved layout.");

        } catch (err) {
            alert("Error loading template file.");
            console.error(err);
        }
    };
    reader.readAsText(file);
    event.target.value = ''; // Reset input so the same file can be loaded again if needed
}
</script>
</body>
</html>